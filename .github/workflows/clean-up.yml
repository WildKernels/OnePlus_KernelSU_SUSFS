name: üßπ Cache & Workflow Cleanup

on:
  workflow_dispatch:
    inputs:
      cleanup_type:
        description: 'Cleanup scope'
        required: true
        type: choice
        default: 'analyze_only'
        options:
          - cache_only
          - runs_only
          - full_cleanup
          - analyze_only
      
      device_filter:
        description: 'Device/Kernel filter (ALL, device code, or kernel version)'
        required: false
        type: choice
        default: 'ALL'
        options:
          - ALL
          - android15-6.6
          - android14-6.1
          - android14-5.15
          - android13-5.15
          - android13-5.10
          - android12-5.10
          - OP13-CPH
          - OP13-PJZ
          - OP13r
          - OP13S
          - OP13T
          - OP12
          - OP12r
          - OP11
          - OP11r
          - OP10pro
          - OP10t
          - OP-Nord-5
          - OP-NORD-4
          - OP-NORD-4-CE
          - OP-NORD-CE4-LITE
          - OP-ACE-5-PRO
          - OP-ACE-5
          - OP-ACE-3-PRO
          - OP-ACE-3V
          - OP-ACE-2-PRO
          - OP-ACE-2
          - OP-OPEN
          - OP-PAD-3
          - OP-PAD-2-PRO
          - OP-PAD-2
          - OP-PAD-PRO
      
      cache_pattern:
        description: 'Cache cleanup pattern'
        required: false
        type: choice
        default: 'ccache_stale'
        options:
          - all_caches
          - ccache_only
          - ccache_stale
          - apt_only
          - kernel_only
          - old_only
      
      cache_age_days:
        description: 'Delete caches older than (days)'
        required: false
        type: number
        default: 7
      
      dry_run:
        description: 'Dry run (preview only, no deletions)'
        required: false
        type: boolean
        default: true
      
      force_cleanup:
        description: 'Force cleanup (override protections)'
        required: false
        type: boolean
        default: false

permissions:
  actions: write
  contents: read

concurrency:
  group: cache-maintenance
  cancel-in-progress: false

jobs:
  analyze:
    runs-on: ubuntu-latest
    outputs:
      should_cleanup: ${{ steps.analysis.outputs.should_cleanup }}
      total_cache_size: ${{ steps.analysis.outputs.total_size }}
      cache_count: ${{ steps.analysis.outputs.cache_count }}
      usage_percent: ${{ steps.analysis.outputs.usage_percent }}
      ccache_count: ${{ steps.analysis.outputs.ccache_count }}
      ccache_size: ${{ steps.analysis.outputs.ccache_size }}
    
    steps:
      - name: üìä Analyze Repository Cache Health
        id: analysis
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const forceCleanup = '${{ inputs.force_cleanup }}' === 'true';
            
            async function withRetry(fn, maxRetries = 3) {
              for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                  return await fn();
                } catch (error) {
                  const isRateLimit = 
                    error.status === 429 || 
                    error.status === 403 ||
                    error.message?.toLowerCase().includes('rate limit') ||
                    error.message?.toLowerCase().includes('secondary rate limit');
                  
                  if (isRateLimit && attempt < maxRetries - 1) {
                    const backoff = 1000 * Math.pow(2, attempt) + Math.floor(Math.random() * 500);
                    console.log(`‚è≥ Rate limit hit, retrying in ${backoff}ms (attempt ${attempt + 1}/${maxRetries})...`);
                    await new Promise(resolve => setTimeout(resolve, backoff));
                    continue;
                  }
                  throw error;
                }
              }
            }
            
            console.log('üîç Analyzing repository cache health...\n');
            
            let totalCacheSize = 0;
            let cacheCount = 0;
            const allCaches = [];
            
            const cachesByType = {
              ccache: { size: 0, count: 0 },
              apt: { size: 0, count: 0 },
              kernel: { size: 0, count: 0 },
              other: { size: 0, count: 0 }
            };
            
            const cachesByDevice = new Map();
            const cacheKeyVersions = { v4: 0, v3: 0, legacy: 0 };
            
            const cacheAgeDistribution = {
              fresh: 0,
              recent: 0,
              old: 0,
              stale: 0
            };
            
            const lastAccessDistribution = {
              active: 0,
              recent: 0,
              dormant: 0,
              stale: 0
            };
            
            let page = 1;
            while (true) {
              const res = await withRetry(() =>
                github.rest.actions.getActionsCacheList({
                  owner,
                  repo,
                  per_page: 100,
                  page: page
                })
              );
              
              const caches = res.data.actions_caches;
              if (!caches || caches.length === 0) break;
              
              for (const cache of caches) {
                totalCacheSize += cache.size_in_bytes;
                cacheCount++;
                allCaches.push(cache);
                
                const cacheDate = new Date(cache.created_at);
                const lastAccessDate = new Date(cache.last_accessed_at || cache.created_at);
                const ageDays = Math.floor((new Date() - cacheDate) / (1000 * 60 * 60 * 24));
                const accessAgeDays = Math.floor((new Date() - lastAccessDate) / (1000 * 60 * 60 * 24));
                
                if (ageDays < 7) cacheAgeDistribution.fresh++;
                else if (ageDays < 14) cacheAgeDistribution.recent++;
                else if (ageDays < 30) cacheAgeDistribution.old++;
                else cacheAgeDistribution.stale++;
                
                if (accessAgeDays < 7) lastAccessDistribution.active++;
                else if (accessAgeDays < 14) lastAccessDistribution.recent++;
                else if (accessAgeDays < 30) lastAccessDistribution.dormant++;
                else lastAccessDistribution.stale++;
                
                if (cache.key.startsWith('ccache-')) {
                  cachesByType.ccache.size += cache.size_in_bytes;
                  cachesByType.ccache.count++;
                  
                  // ‚úÖ UPDATED: Support both v4 and v3 formats
                  const isV4Format = cache.key.startsWith('ccache-ksun-v4-');
                  const isV3Format = cache.key.startsWith('ccache-ksun-v3-');
                  
                  if (isV4Format) {
                    cacheKeyVersions.v4++;
                  } else if (isV3Format) {
                    cacheKeyVersions.v3++;
                  } else {
                    cacheKeyVersions.legacy++;
                  }
                  
                  let device = null;
                  let osVersion = null;
                  let androidVer = null;
                  let kernelVer = null;
                  
                  // ‚úÖ UPDATED: Parse v4 format (ccache-ksun-v4-MODEL-OS-ANDROID-KERNEL-CLANG-BRANCH)
                  if (isV4Format) {
                    const v4Match = cache.key.match(/^ccache-ksun-v4-([^-]+)-([^-]+)-([^-]+)-([^-]+)-([^-]+)(?:-([^-]+))?$/);
                    if (v4Match) {
                      device = v4Match[1];        // OP13
                      osVersion = v4Match[2];     // OOS15
                      androidVer = v4Match[3];    // android14
                      kernelVer = v4Match[4];     // 6.1
                      // clangVer = v4Match[5];   // r510928
                      // branch = v4Match[6];     // stable (optional)
                    }
                  } else if (isV3Format) {
                    const v3Match = cache.key.match(/^ccache-ksun-v3-([^-]+-[\d.]+)-([A-Za-z0-9.-]+(?:-[A-Za-z0-9.-]+)*)-(clang-[A-Za-z0-9.-]+)-([A-Za-z0-9._-]+)(-stable)?$/);
                    if (v3Match) {
                      osVersion = v3Match[2];
                      device = v3Match[4];
                    }
                  } else {
                    // Legacy format parsing
                    const legacy1 = cache.key.match(/^ccache-[^-]+-[\d.]+-[^-]+-clang-[^-]+-([^-]+)$/);
                    const legacy2 = cache.key.match(/^ccache-[^-]+-[\d.]+-[^-]+-([^-]+)$/);
                    const legacy3 = cache.key.match(/ccache-[^-]+-[^-]+-[^-]+-[^-]+-([^-]+)/);
                    
                    device = legacy1?.[1] || legacy2?.[1] || legacy3?.[1] || null;
                  }
                  
                  if (device) {
                    if (!cachesByDevice.has(device)) {
                      cachesByDevice.set(device, {
                        size: 0,
                        count: 0,
                        lastAccessed: lastAccessDate,
                        oldestCache: cacheDate,
                        newestCache: cacheDate,
                        oldestAccess: lastAccessDate,
                        newestAccess: lastAccessDate,
                        osVersions: new Set(),
                        v4Count: 0,
                        v3Count: 0,
                        legacyCount: 0
                      });
                    }
                    
                    const deviceData = cachesByDevice.get(device);
                    deviceData.size += cache.size_in_bytes;
                    deviceData.count++;
                    
                    // ‚úÖ UPDATED: Track v4, v3, and legacy counts
                    if (isV4Format) deviceData.v4Count++;
                    else if (isV3Format) deviceData.v3Count++;
                    else deviceData.legacyCount++;
                    
                    if (osVersion) deviceData.osVersions.add(osVersion);
                    
                    if (lastAccessDate > deviceData.lastAccessed) {
                      deviceData.lastAccessed = lastAccessDate;
                    }
                    if (cacheDate < deviceData.oldestCache) {
                      deviceData.oldestCache = cacheDate;
                    }
                    if (cacheDate > deviceData.newestCache) {
                      deviceData.newestCache = cacheDate;
                    }
                    if (lastAccessDate < deviceData.oldestAccess) {
                      deviceData.oldestAccess = lastAccessDate;
                    }
                    if (lastAccessDate > deviceData.newestAccess) {
                      deviceData.newestAccess = lastAccessDate;
                    }
                  }
                } else if (cache.key.startsWith('apt-')) {
                  cachesByType.apt.size += cache.size_in_bytes;
                  cachesByType.apt.count++;
                } else if (cache.key.includes('kernel') || cache.key.includes('linux-')) {
                  cachesByType.kernel.size += cache.size_in_bytes;
                  cachesByType.kernel.count++;
                } else {
                  cachesByType.other.size += cache.size_in_bytes;
                  cachesByType.other.count++;
                }
              }
              
              if (caches.length < 100) break;
              page++;
            }
            
            const totalSizeGB = (totalCacheSize / 1024 / 1024 / 1024).toFixed(2);
            const maxCacheSize = 10 * 1024 * 1024 * 1024;
            const usagePercent = ((totalCacheSize / maxCacheSize) * 100).toFixed(1);
            
            let healthEmoji = 'üü¢';
            let healthStatus = 'Healthy';
            if (parseFloat(usagePercent) > 90) {
              healthEmoji = 'üî¥';
              healthStatus = 'Critical';
            } else if (parseFloat(usagePercent) > 75) {
              healthEmoji = 'üü°';
              healthStatus = 'Warning';
            }
            
            console.log(`\nüìä Cache Analysis Complete:`);
            console.log(`   Total Size: ${totalSizeGB} GB (${usagePercent}% of 10 GB limit)`);
            console.log(`   Total Caches: ${cacheCount}`);
            console.log(`   Health: ${healthEmoji} ${healthStatus}\n`);
            
            const summary = core.summary
              .addHeading(`${healthEmoji} Repository Cache Health Report`, 2)
              .addRaw(`\n**Analysis Date:** ${new Date().toISOString()}\n\n`);
            
            summary.addHeading('üìä Overall Statistics', 3)
              .addTable([
                [{data: 'Metric', header: true}, {data: 'Value', header: true}, {data: 'Status', header: true}],
                ['Total Cache Size', `${totalSizeGB} GB`, `${usagePercent}% of 10 GB`],
                ['Total Cache Count', cacheCount.toString(), healthEmoji],
                ['Health Status', healthStatus, healthEmoji],
                ['Recommendation', usagePercent > 75 ? '‚ö†Ô∏è Cleanup recommended' : '‚úÖ No action needed', '']
              ]);
            
            summary.addHeading('üóÇÔ∏è Cache Breakdown by Type', 3)
              .addTable([
                [{data: 'Type', header: true}, {data: 'Count', header: true}, {data: 'Size (GB)', header: true}, {data: 'Percentage', header: true}],
                ['ccache', 
                 cachesByType.ccache.count.toString(),
                 (cachesByType.ccache.size / 1024 / 1024 / 1024).toFixed(2),
                 `${((cachesByType.ccache.size / totalCacheSize) * 100).toFixed(1)}%`],
                ['apt packages',
                 cachesByType.apt.count.toString(),
                 (cachesByType.apt.size / 1024 / 1024 / 1024).toFixed(2),
                 `${((cachesByType.apt.size / totalCacheSize) * 100).toFixed(1)}%`],
                ['kernel sources',
                 cachesByType.kernel.count.toString(),
                 (cachesByType.kernel.size / 1024 / 1024 / 1024).toFixed(2),
                 `${((cachesByType.kernel.size / totalCacheSize) * 100).toFixed(1)}%`],
                ['other',
                 cachesByType.other.count.toString(),
                 (cachesByType.other.size / 1024 / 1024 / 1024).toFixed(2),
                 `${((cachesByType.other.size / totalCacheSize) * 100).toFixed(1)}%`]
              ]);
            
            // ‚úÖ UPDATED: Show v4, v3, and legacy breakdown
            const totalVersionedCaches = cacheKeyVersions.v4 + cacheKeyVersions.v3 + cacheKeyVersions.legacy;
            summary.addHeading('üîë Cache Key Versions', 3)
              .addTable([
                [{data: 'Format', header: true}, {data: 'Count', header: true}, {data: 'Percentage', header: true}],
                ['v4 (ccache-ksun-v4-*)', 
                 cacheKeyVersions.v4.toString(),
                 totalVersionedCaches > 0 ? `${((cacheKeyVersions.v4 / totalVersionedCaches) * 100).toFixed(1)}%` : '0%'],
                ['v3 (ccache-ksun-v3-*)', 
                 cacheKeyVersions.v3.toString(),
                 totalVersionedCaches > 0 ? `${((cacheKeyVersions.v3 / totalVersionedCaches) * 100).toFixed(1)}%` : '0%'],
                ['Legacy (old format)',
                 cacheKeyVersions.legacy.toString(),
                 totalVersionedCaches > 0 ? `${((cacheKeyVersions.legacy / totalVersionedCaches) * 100).toFixed(1)}%` : '0%']
              ]);
            
            // ‚úÖ UPDATED: Warnings for v3 and legacy caches
            if (cacheKeyVersions.v3 > 0) {
              summary.addRaw(`\n> ‚ÑπÔ∏è **v3 Cache Keys Detected**: ${cacheKeyVersions.v3} caches use v3 format. Consider migrating to v4 for consistency.\n\n`);
            }
            if (cacheKeyVersions.legacy > 0) {
              summary.addRaw(`\n> ‚ö†Ô∏è **Legacy Cache Keys Detected**: ${cacheKeyVersions.legacy} caches use old format. Strongly recommend migrating to v4 format.\n\n`);
            }
            
            summary.addHeading('üìÖ Cache Age Distribution (by creation date)', 3)
              .addTable([
                [{data: 'Age Range', header: true}, {data: 'Count', header: true}, {data: 'Percentage', header: true}],
                ['< 7 days (Fresh)', cacheAgeDistribution.fresh.toString(), `${((cacheAgeDistribution.fresh / cacheCount) * 100).toFixed(1)}%`],
                ['7-14 days (Recent)', cacheAgeDistribution.recent.toString(), `${((cacheAgeDistribution.recent / cacheCount) * 100).toFixed(1)}%`],
                ['14-30 days (Old)', cacheAgeDistribution.old.toString(), `${((cacheAgeDistribution.old / cacheCount) * 100).toFixed(1)}%`],
                ['> 30 days (Stale)', cacheAgeDistribution.stale.toString(), `${((cacheAgeDistribution.stale / cacheCount) * 100).toFixed(1)}%`]
              ]);
            
            summary.addHeading('üîÑ Activity Distribution (by last access)', 3)
              .addTable([
                [{data: 'Activity Level', header: true}, {data: 'Count', header: true}, {data: 'Percentage', header: true}],
                ['< 7 days (Active)', lastAccessDistribution.active.toString(), `${((lastAccessDistribution.active / cacheCount) * 100).toFixed(1)}%`],
                ['7-14 days (Recent)', lastAccessDistribution.recent.toString(), `${((lastAccessDistribution.recent / cacheCount) * 100).toFixed(1)}%`],
                ['14-30 days (Dormant)', lastAccessDistribution.dormant.toString(), `${((lastAccessDistribution.dormant / cacheCount) * 100).toFixed(1)}%`],
                ['> 30 days (Stale)', lastAccessDistribution.stale.toString(), `${((lastAccessDistribution.stale / cacheCount) * 100).toFixed(1)}%`]
              ]);
            
            // ===== FIX: Move deviceArray and inactiveDevices to outer scope =====
            const deviceArray = Array.from(cachesByDevice.entries())
              .sort((a, b) => b[1].size - a[1].size);
            
            const inactiveDevices = deviceArray.filter(([_, data]) => {
              const daysSinceAccess = Math.floor((new Date() - data.lastAccessed) / (1000 * 60 * 60 * 24));
              return daysSinceAccess > 30;
            });
            
            if (deviceArray.length > 0) {
              // ‚úÖ UPDATED: Show v4/v3/Legacy counts per device
              summary.addHeading('üì± Top 15 Devices by Cache Size', 3)
                .addTable([
                  [{data: 'Device', header: true}, {data: 'Count', header: true}, {data: 'Size (GB)', header: true}, 
                   {data: 'v4/v3/Legacy', header: true}, {data: 'Last Access', header: true}, {data: 'OS Versions', header: true}],
                  ...deviceArray.slice(0, 15).map(([device, data]) => [
                    device,
                    data.count.toString(),
                    (data.size / 1024 / 1024 / 1024).toFixed(2),
                    `${data.v4Count}/${data.v3Count}/${data.legacyCount}`,
                    `${Math.floor((new Date() - data.lastAccessed) / (1000 * 60 * 60 * 24))}d ago`,
                    Array.from(data.osVersions).join(', ') || 'N/A'
                  ])
                ]);
              
              if (inactiveDevices.length > 0) {
                summary.addHeading('‚ö†Ô∏è Inactive Devices (>30 days since last access)', 3)
                  .addTable([
                    [{data: 'Device', header: true}, {data: 'Count', header: true}, {data: 'Size (GB)', header: true}, 
                     {data: 'Last Access', header: true}, {data: 'Potential Savings', header: true}],
                    ...inactiveDevices.slice(0, 10).map(([device, data]) => [
                      device,
                      data.count.toString(),
                      (data.size / 1024 / 1024 / 1024).toFixed(2),
                      `${Math.floor((new Date() - data.lastAccessed) / (1000 * 60 * 60 * 24))}d ago`,
                      `${((data.size / totalCacheSize) * 100).toFixed(1)}%`
                    ])
                  ]);
                
                const potentialSavings = inactiveDevices.reduce((sum, [_, data]) => sum + data.size, 0);
                const savingsGB = (potentialSavings / 1024 / 1024 / 1024).toFixed(2);
                summary.addRaw(`\n> üí° **Potential Savings**: Cleaning inactive devices could free up **${savingsGB} GB** (${((potentialSavings / totalCacheSize) * 100).toFixed(1)}% of total)\n\n`);
              }
            }
            
            const oldestCaches = allCaches
              .sort((a, b) => new Date(a.created_at) - new Date(b.created_at))
              .slice(0, 10);
            
            const newestCaches = allCaches
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
              .slice(0, 10);
            
            summary.addHeading('üìÖ Cache Age Information', 3)
              .addRaw(`\n**Oldest Cache:** ${oldestCaches[0]?.key || 'N/A'} (${Math.floor((new Date() - new Date(oldestCaches[0]?.created_at)) / (1000 * 60 * 60 * 24))} days old)\n\n`)
              .addRaw(`**Newest Cache:** ${newestCaches[0]?.key || 'N/A'} (${Math.floor((new Date() - new Date(newestCaches[0]?.created_at)) / (1000 * 60 * 60 * 24))} days old)\n\n`);
            
            summary.addHeading('üí° Recommendations', 3);
            
            if (parseFloat(usagePercent) > 90) {
              summary.addRaw(`\n‚ö†Ô∏è **Action Required**: Cache usage is critical (${usagePercent}%). Immediate cleanup recommended.\n\n`);
            } else if (parseFloat(usagePercent) > 75) {
              summary.addRaw(`\n‚ö†Ô∏è **Warning**: Cache usage is high (${usagePercent}%). Consider cleanup soon.\n\n`);
            } else {
              summary.addRaw(`\n‚úÖ **Healthy**: Cache usage is normal (${usagePercent}%). No immediate action needed.\n\n`);
            }
            
            // ‚úÖ UPDATED: Recommendations for v3 and legacy caches
            if (cacheKeyVersions.v3 > 0) {
              summary.addRaw(`- üîÑ **v3 Migration**: ${cacheKeyVersions.v3} v3 caches detected. Consider migrating to v4 format for consistency.\n`);
            }
            if (cacheKeyVersions.legacy > 0) {
              summary.addRaw(`- üîÑ **Legacy Migration**: ${cacheKeyVersions.legacy} legacy caches detected. Run migration cleanup to adopt v4 format.\n`);
            }
            
            if (lastAccessDistribution.stale > 0) {
              summary.addRaw(`- üßπ **Stale Caches**: ${lastAccessDistribution.stale} caches haven't been accessed in 30+ days.\n`);
            }
            
            // ===== FIX: Now inactiveDevices is accessible here =====
            if (inactiveDevices.length > 0) {
              summary.addRaw(`- üì± **Inactive Devices**: ${inactiveDevices.length} devices haven't been built in 30+ days.\n`);
            }
            
            await summary.write();
            
            core.setOutput('should_cleanup', usagePercent > 75 ? 'true' : 'false');
            core.setOutput('total_size', totalSizeGB);
            core.setOutput('cache_count', cacheCount);
            core.setOutput('usage_percent', usagePercent);
            core.setOutput('ccache_count', cachesByType.ccache.count);
            core.setOutput('ccache_size', (cachesByType.ccache.size / 1024 / 1024 / 1024).toFixed(2));

  cleanup-caches:
    runs-on: ubuntu-latest
    needs: analyze
    if: |
      inputs.cleanup_type == 'cache_only' || 
      inputs.cleanup_type == 'full_cleanup'
    
    steps:
      - name: üßπ Cleanup Caches
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const dryRun = '${{ inputs.dry_run }}' === 'true';
            const deviceFilter = '${{ inputs.device_filter }}';
            const cachePattern = '${{ inputs.cache_pattern }}';
            const cacheAgeDays = parseInt('${{ inputs.cache_age_days }}');
            const forceCleanup = '${{ inputs.force_cleanup }}' === 'true';
            
            async function withRetry(fn, maxRetries = 3) {
              for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                  return await fn();
                } catch (error) {
                  const isRateLimit = 
                    error.status === 429 || 
                    error.status === 403 ||
                    error.message?.toLowerCase().includes('rate limit') ||
                    error.message?.toLowerCase().includes('secondary rate limit');
                  
                  if (isRateLimit && attempt < maxRetries - 1) {
                    const backoff = 1000 * Math.pow(2, attempt) + Math.floor(Math.random() * 500);
                    console.log(`‚è≥ Rate limit hit, retrying in ${backoff}ms (attempt ${attempt + 1}/${maxRetries})...`);
                    await new Promise(resolve => setTimeout(resolve, backoff));
                    continue;
                  }
                  throw error;
                }
              }
            }
            
            console.log('üßπ Starting cache cleanup...\n');
            console.log(`Configuration:`);
            console.log(`  Device Filter: ${deviceFilter}`);
            console.log(`  Cache Pattern: ${cachePattern}`);
            console.log(`  Age Threshold: ${cacheAgeDays} days`);
            console.log(`  Dry Run: ${dryRun}`);
            console.log(`  Force Cleanup: ${forceCleanup}\n`);
            
            const staleCutoffDate = new Date(Date.now() - cacheAgeDays * 24 * 60 * 60 * 1000);
            const veryStaleCutoffDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
            const veryRecentCutoffDate = new Date(Date.now() - 2 * 60 * 60 * 1000);
            
            function shouldDeleteCache(cache) {
              const cacheKey = cache.key;
              const cacheDate = new Date(cache.created_at);
              const lastAccessDate = new Date(cache.last_accessed_at || cache.created_at);
              const ageDays = Math.floor((new Date() - cacheDate) / (1000 * 60 * 60 * 24));
              const accessAgeDays = Math.floor((new Date() - lastAccessDate) / (1000 * 60 * 60 * 24));
              
              // ‚úÖ UPDATED: Support v4 format
              const isV4Format = cacheKey.startsWith('ccache-ksun-v4-');
              const isV3Format = cacheKey.startsWith('ccache-ksun-v3-');
              const isStableKey = cacheKey.endsWith('-stable');
              
              if (lastAccessDate > veryRecentCutoffDate && !forceCleanup) {
                return { delete: false, reason: 'recently_used', accessAgeDays: Math.floor((new Date() - lastAccessDate) / (1000 * 60 * 60)) };
              }
              
              let device = null;
              let kernel = null;
              let osVersion = null;
              
              // ‚úÖ UPDATED: Parse v4 format
              if (isV4Format) {
                const v4Match = cacheKey.match(/^ccache-ksun-v4-([^-]+)-([^-]+)-([^-]+)-([^-]+)-([^-]+)(?:-([^-]+))?$/);
                if (v4Match) {
                  device = v4Match[1];        // OP13
                  osVersion = v4Match[2];     // OOS15
                  // androidVer = v4Match[3]; // android14
                  kernel = v4Match[4];        // 6.1
                  // clangVer = v4Match[5];   // r510928
                  // branch = v4Match[6];     // stable (optional)
                }
              } else if (isV3Format) {
                const v3Match = cacheKey.match(/^ccache-ksun-v3-([^-]+-[\d.]+)-([A-Za-z0-9.-]+(?:-[A-Za-z0-9.-]+)*)-(clang-[A-Za-z0-9.-]+)-([A-Za-z0-9._-]+)(-stable)?$/);
                if (v3Match) {
                  kernel = v3Match[1];
                  osVersion = v3Match[2];
                  device = v3Match[4];
                }
              } else if (cacheKey.startsWith('ccache-')) {
                const kernelMatch = cacheKey.match(/^ccache-([^-]+-[\d.]+)-/);
                if (kernelMatch) kernel = kernelMatch[1];
                
                const legacy1 = cacheKey.match(/^ccache-[^-]+-[\d.]+-[^-]+-clang-[^-]+-([^-]+)$/);
                const legacy2 = cacheKey.match(/^ccache-[^-]+-[\d.]+-[^-]+-([^-]+)$/);
                const legacy3 = cacheKey.match(/ccache-[^-]+-[^-]+-[^-]+-[^-]+-([^-]+)/);
                
                device = legacy1?.[1] || legacy2?.[1] || legacy3?.[1] || null;
              }
              
              const exactMatch =
                deviceFilter === 'ALL' ||
                (device && deviceFilter.toLowerCase() === device.toLowerCase()) ||
                (kernel && deviceFilter.toLowerCase() === kernel.toLowerCase());
              
              const looseMatch =
                cacheKey.includes(`-${deviceFilter}-`) ||
                cacheKey.endsWith(`-${deviceFilter}`) ||
                cacheKey.startsWith(`${deviceFilter}-`);
              
              const deviceMatchesFilter = exactMatch || looseMatch;
              
              if (!deviceMatchesFilter) {
                return { delete: false, reason: 'device_filter' };
              }
              
              let patternMatch = false;
              let category = 'other';
              
              switch (cachePattern) {
                case 'all_caches':
                  patternMatch = true;
                  category = cacheKey.startsWith('ccache-') ? 'ccache' :
                            cacheKey.startsWith('apt-') ? 'apt' :
                            (cacheKey.includes('kernel') || cacheKey.includes('linux-')) ? 'kernel' : 'other';
                  break;
                
                case 'ccache_only':
                  if (cacheKey.startsWith('ccache-')) {
                    patternMatch = true;
                    category = 'ccache';
                  }
                  break;
                
                case 'ccache_stale':
                  if (cacheKey.startsWith('ccache-') && lastAccessDate < staleCutoffDate) {
                    // ‚úÖ UPDATED: Protect both v4 and v3 stable keys
                    if ((isV4Format || isV3Format) && isStableKey && lastAccessDate >= veryStaleCutoffDate && !forceCleanup) {
                      return { delete: false, reason: 'stable_recent' };
                    }
                    patternMatch = true;
                    category = 'ccache';
                  }
                  break;
                
                case 'apt_only':
                  if (cacheKey.startsWith('apt-')) {
                    patternMatch = true;
                    category = 'apt';
                  }
                  break;
                
                case 'kernel_only':
                  if (cacheKey.includes('kernel') || cacheKey.includes('linux-')) {
                    patternMatch = true;
                    category = 'kernel';
                  }
                  break;
                
                case 'old_only':
                  if (cacheDate < staleCutoffDate) {
                    patternMatch = true;
                    category = cacheKey.startsWith('ccache-') ? 'ccache' :
                              cacheKey.startsWith('apt-') ? 'apt' :
                              (cacheKey.includes('kernel') || cacheKey.includes('linux-')) ? 'kernel' : 'other';
                  }
                  break;
              }
              
              return { 
                delete: patternMatch, 
                reason: patternMatch ? 'match' : 'pattern_mismatch',
                category: category
              };
            }
            
            // Fetch and process caches
            console.log('üîç Scanning caches...\n');
            
            while (true) {
              const res = await github.rest.actions.getActionsCacheList({
                owner,
                repo,
                per_page: 100,
                page: page
              });
              
              const caches = res.data.actions_caches;
              if (!caches || caches.length === 0) break;
              
              for (const cache of caches) {
                const decision = shouldDeleteCache(cache);
                const sizeMB = (cache.size_in_bytes / 1024 / 1024).toFixed(2);
                const agedays = Math.floor((new Date() - new Date(cache.created_at)) / (1000 * 60 * 60 * 24));
                
                if (decision.delete) {
                  deletedCaches.push({
                    key: cache.key,
                    size: sizeMB,
                    sizeBytes: cache.size_in_bytes,
                    age: agedays,
                    created: cache.created_at,
                    id: cache.id,
                    category: decision.category
                  });
                  
                  if (dryRun) {
                    console.log(`üîç Would delete: ${cache.key}`);
                    console.log(`   Size: ${sizeMB} MB | Age: ${agedays} days | Type: ${decision.category}`);
                  } else {
                    console.log(`üóëÔ∏è Deleting: ${cache.key}`);
                    console.log(`   Size: ${sizeMB} MB | Age: ${agedays} days | Type: ${decision.category}`);
                    
                    try {
                      await github.rest.actions.deleteActionsCacheById({
                        owner,
                        repo,
                        cache_id: cache.id
                      });
                      totalDeleted++;
                      totalSize += cache.size_in_bytes;
                      
                      // Update category stats
                      deletionStats[decision.category].count++;
                      deletionStats[decision.category].size += cache.size_in_bytes;
                    } catch (error) {
                      console.log(`   ‚ö†Ô∏è Failed: ${error.message}`);
                      skippedCaches.push({
                        key: cache.key,
                        reason: error.message
                      });
                    }
                  }
                } else if (decision.reason !== 'device_filter') {
                  // Only log non-device-filter skips in verbose mode
                  // console.log(`‚è≠Ô∏è Skipping: ${cache.key} (${decision.reason})`);
                }
              }
              
              if (caches.length < 100) break;
              page++;
            }
            
            const freedGB = (totalFreed / 1024 / 1024 / 1024).toFixed(2);
            
            console.log(`\n‚úÖ Cleanup ${dryRun ? 'simulation' : 'complete'}:`);
            console.log(`   ${dryRun ? 'Would delete' : 'Deleted'}: ${totalDeleted} caches`);
            console.log(`   ${dryRun ? 'Would free' : 'Freed'}: ${freedGB} GB\n`);
            
            const summary = core.summary
              .addHeading(`üßπ Cache Cleanup ${dryRun ? 'Preview' : 'Report'}`, 2)
              .addRaw(`\n**Cleanup Date:** ${new Date().toISOString()}\n\n`);
            
            if (dryRun) {
              summary.addRaw(`> ‚ö†Ô∏è **DRY RUN MODE** - No caches were actually deleted. This is a preview of what would be deleted.\n\n`);
            }
            
            summary.addHeading('üìä Cleanup Summary', 3)
              .addTable([
                [{data: 'Metric', header: true}, {data: 'Value', header: true}],
                ['Caches ' + (dryRun ? 'to Delete' : 'Deleted'), totalDeleted.toString()],
                ['Space ' + (dryRun ? 'to Free' : 'Freed'), `${freedGB} GB`],
                ['Device Filter', deviceFilter],
                ['Cache Pattern', cachePattern],
                ['Age Threshold', `${cacheAgeDays} days`],
                ['Force Cleanup', forceCleanup ? 'Yes' : 'No']
              ]);
            
            summary.addHeading('üóÇÔ∏è Deletion Breakdown by Type', 3)
              .addTable([
                [{data: 'Type', header: true}, {data: 'Count', header: true}, {data: 'Size (GB)', header: true}, {data: 'Percentage', header: true}],
                ['ccache',
                 deletionStats.ccache.count.toString(),
                 (deletionStats.ccache.size / 1024 / 1024 / 1024).toFixed(2),
                 totalFreed > 0 ? `${((deletionStats.ccache.size / totalFreed) * 100).toFixed(1)}%` : '0%'],
                ['apt packages',
                 deletionStats.apt.count.toString(),
                 (deletionStats.apt.size / 1024 / 1024 / 1024).toFixed(2),
                 totalFreed > 0 ? `${((deletionStats.apt.size / totalFreed) * 100).toFixed(1)}%` : '0%'],
                ['kernel sources',
                 deletionStats.kernel.count.toString(),
                 (deletionStats.kernel.size / 1024 / 1024 / 1024).toFixed(2),
                 totalFreed > 0 ? `${((deletionStats.kernel.size / totalFreed) * 100).toFixed(1)}%` : '0%'],
                ['other',
                 deletionStats.other.count.toString(),
                 (deletionStats.other.size / 1024 / 1024 / 1024).toFixed(2),
                 totalFreed > 0 ? `${((deletionStats.other.size / totalFreed) * 100).toFixed(1)}%` : '0%']
              ]);
            
            if (deletionStats.ccache.count > 0) {
              // ‚úÖ UPDATED: Show v4, v3, and legacy breakdown
              summary.addHeading('üîë ccache Format Breakdown', 3)
                .addTable([
                  [{data: 'Format', header: true}, {data: 'Count', header: true}, {data: 'Percentage', header: true}],
                  ['v4 format', 
                   deletionStats.ccache.v4.toString(),
                   `${((deletionStats.ccache.v4 / deletionStats.ccache.count) * 100).toFixed(1)}%`],
                  ['v3 format', 
                   deletionStats.ccache.v3.toString(),
                   `${((deletionStats.ccache.v3 / deletionStats.ccache.count) * 100).toFixed(1)}%`],
                  ['Legacy format',
                   deletionStats.ccache.legacy.toString(),
                   `${((deletionStats.ccache.legacy / deletionStats.ccache.count) * 100).toFixed(1)}%`],
                  ['Stable keys',
                   deletionStats.ccache.stable.toString(),
                   `${((deletionStats.ccache.stable / deletionStats.ccache.count) * 100).toFixed(1)}%`]
                ]);
            }
            
            // ‚úÖ UPDATED: Protection rules for v4 and v3
            summary.addRaw(`\n### üõ°Ô∏è Active Protection Rules\n\n`)
              .addTable([
                [{data: 'Protection', header: true}, {data: 'Threshold', header: true}, {data: 'Status', header: true}],
                ['v4/v3 Stable Keys', '30 days since last access', forceCleanup ? '‚úÖ Overridden' : 'üîí Active'],
                ['Recently Used Caches', '2 hours since last access', forceCleanup ? '‚úÖ Overridden' : 'üîí Active'],
                ['Device Filter', deviceFilter, 'Active'],
                ['Age Threshold', `${cacheAgeDays} days`, 'Active']
              ]);
            
            if (deletedCaches.length > 0) {
              const largestDeleted = deletedCaches
                .sort((a, b) => b.size - a.size)
                .slice(0, 20);
              
              summary.addHeading('üì¶ Top 20 Largest Caches ' + (dryRun ? 'to Delete' : 'Deleted'), 3)
                .addTable([
                  [{data: 'Cache Key', header: true}, {data: 'Size (MB)', header: true}, 
                   {data: 'Category', header: true}, {data: 'Last Access', header: true}],
                  ...largestDeleted.map(cache => [
                    cache.key,
                    (cache.size / 1024 / 1024).toFixed(2),
                    cache.category,
                    `${cache.accessAgeDays}d ago`
                  ])
                ]);
              
              const stalestDeleted = deletedCaches
                .sort((a, b) => new Date(a.accessed) - new Date(b.accessed))
                .slice(0, 10);
              
              summary.addHeading('‚è∞ Top 10 Most Stale Caches (by last access)', 3)
                .addTable([
                  [{data: 'Cache Key', header: true}, {data: 'Last Access', header: true}, 
                   {data: 'Size (MB)', header: true}, {data: 'Device', header: true}],
                  ...stalestDeleted.map(cache => [
                    cache.key,
                    `${cache.accessAgeDays}d ago`,
                    (cache.size / 1024 / 1024).toFixed(2),
                    cache.device || 'N/A'
                  ])
                ]);
              
              if (deletedDevices.size > 0) {
                const deviceDeletions = new Map();
                deletedCaches
                  .filter(c => c.device && c.category === 'ccache')
                  .forEach(c => {
                    if (!deviceDeletions.has(c.device)) {
                      deviceDeletions.set(c.device, { count: 0, size: 0 });
                    }
                    const stats = deviceDeletions.get(c.device);
                    stats.count++;
                    stats.size += c.size;
                  });
                
                const topDevices = Array.from(deviceDeletions.entries())
                  .sort((a, b) => b[1].size - a[1].size)
                  .slice(0, 10);
                
                summary.addHeading('üì± Top 10 Devices by Deleted ccache', 3)
                  .addTable([
                    [{data: 'Device', header: true}, {data: 'Caches Deleted', header: true}, {data: 'Size (GB)', header: true}],
                    ...topDevices.map(([device, stats]) => [
                      device,
                      stats.count.toString(),
                      (stats.size / 1024 / 1024 / 1024).toFixed(2)
                    ])
                  ]);
              }
            }
            
            if (failedDeletions.length > 0) {
              summary.addHeading('‚ùå Failed Deletions', 3)
                .addTable([
                  [{data: 'Cache Key', header: true}, {data: 'Error', header: true}],
                  ...failedDeletions.map(f => [f.key, f.error])
                ]);
            }
            
            await summary.write();

  cleanup-runs:
    runs-on: ubuntu-latest
    needs: analyze
    if: |
      inputs.cleanup_type == 'runs_only' || 
      inputs.cleanup_type == 'full_cleanup'
    
    steps:
      - name: üóëÔ∏è Cleanup Old Workflow Runs
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const dryRun = '${{ inputs.dry_run }}' === 'true';
            const keepDays = 30;
            const keepRecent = 5;
            
            async function withRetry(fn, maxRetries = 3) {
              for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                  return await fn();
                } catch (error) {
                  const isRateLimit = 
                    error.status === 429 || 
                    error.status === 403 ||
                    error.message?.toLowerCase().includes('rate limit') ||
                    error.message?.toLowerCase().includes('secondary rate limit');
                  
                  if (isRateLimit && attempt < maxRetries - 1) {
                    const backoff = 1000 * Math.pow(2, attempt) + Math.floor(Math.random() * 500);
                    console.log(`‚è≥ Rate limit hit, retrying in ${backoff}ms (attempt ${attempt + 1}/${maxRetries})...`);
                    await new Promise(resolve => setTimeout(resolve, backoff));
                    continue;
                  }
                  throw error;
                }
              }
            }
            
            console.log('üóëÔ∏è Starting workflow runs cleanup...\n');
            console.log(`Configuration:`);
            console.log(`  Keep Days: ${keepDays}`);
            console.log(`  Keep Recent Successful: ${keepRecent}`);
            console.log(`  Dry Run: ${dryRun}\n`);
            
            const cutoffDate = new Date(Date.now() - keepDays * 24 * 60 * 60 * 1000);
            
            let totalDeleted = 0;
            const deletionsByWorkflow = new Map();
            const deletionsByStatus = {
              failed: 0,
              cancelled: 0,
              skipped: 0,
              success: 0
            };
            
            const workflows = await withRetry(() =>
              github.rest.actions.listRepoWorkflows({
                owner,
                repo
              })
            );
            
            for (const workflow of workflows.data.workflows) {
              console.log(`\nüìã Processing workflow: ${workflow.name}`);
              
              const successfulRuns = [];
              let page = 1;
              
              while (true) {
                const runs = await withRetry(() =>
                  github.rest.actions.listWorkflowRuns({
                    owner,
                    repo,
                    workflow_id: workflow.id,
                    per_page: 100,
                    page: page
                  })
                );
                
                if (!runs.data.workflow_runs || runs.data.workflow_runs.length === 0) break;
                
                for (const run of runs.data.workflow_runs) {
                  const runDate = new Date(run.created_at);
                  const isOld = runDate < cutoffDate;
                  
                  const isFailed = run.conclusion === 'failure';
                  const isCancelled = run.conclusion === 'cancelled';
                  const isSkipped = run.conclusion === 'skipped';
                  
                  if (run.conclusion === 'success') {
                    successfulRuns.push(run);
                  }
                  
                  const tooManySuccessful = run.conclusion === 'success' && 
                                           runDate < cutoffDate &&
                                           successfulRuns.length > keepRecent;
                  
                  const shouldDelete = 
                    (isFailed && isOld) ||
                    (isCancelled && isOld) ||
                    (isSkipped && isOld) ||
                    tooManySuccessful;
                  
                  if (shouldDelete) {
                    console.log(`${dryRun ? '[DRY RUN] Would delete' : 'Deleting'}: Run #${run.run_number} (${run.conclusion}, ${Math.floor((new Date() - runDate) / (1000 * 60 * 60 * 24))}d old)`);
                    
                    if (!dryRun) {
                      try {
                        await withRetry(() =>
                          github.rest.actions.deleteWorkflowRun({
                            owner,
                            repo,
                            run_id: run.id
                          })
                        );
                      } catch (error) {
                        console.error(`‚ùå Failed to delete run #${run.run_number}: ${error.message}`);
                        continue;
                      }
                    }
                    
                    totalDeleted++;
                    
                    if (!deletionsByWorkflow.has(workflow.name)) {
                      deletionsByWorkflow.set(workflow.name, 0);
                    }
                    deletionsByWorkflow.set(workflow.name, deletionsByWorkflow.get(workflow.name) + 1);
                    
                    if (isFailed) deletionsByStatus.failed++;
                    else if (isCancelled) deletionsByStatus.cancelled++;
                    else if (isSkipped) deletionsByStatus.skipped++;
                    else if (run.conclusion === 'success') deletionsByStatus.success++;
                  }
                }
                
                if (runs.data.workflow_runs.length < 100) break;
                page++;
              }
            }
            
            console.log(`\n‚úÖ Runs cleanup ${dryRun ? 'simulation' : 'complete'}:`);
            console.log(`   ${dryRun ? 'Would delete' : 'Deleted'}: ${totalDeleted} runs\n`);
            
            const summary = core.summary
              .addHeading(`üóëÔ∏è Workflow Runs Cleanup ${dryRun ? 'Preview' : 'Report'}`, 2)
              .addRaw(`\n**Cleanup Date:** ${new Date().toISOString()}\n\n`);
            
            if (dryRun) {
              summary.addRaw(`> ‚ö†Ô∏è **DRY RUN MODE** - No runs were actually deleted. This is a preview.\n\n`);
            }
            
            summary.addHeading('üìä Cleanup Summary', 3)
              .addTable([
                [{data: 'Metric', header: true}, {data: 'Value', header: true}],
                ['Runs ' + (dryRun ? 'to Delete' : 'Deleted'), totalDeleted.toString()],
                ['Keep Days', `${keepDays} days`],
                ['Keep Recent Successful', `${keepRecent} per workflow`]
              ]);
            
            summary.addHeading('üìà Deletions by Status', 3)
              .addTable([
                [{data: 'Status', header: true}, {data: 'Count', header: true}, {data: 'Percentage', header: true}],
                ['Failed', deletionsByStatus.failed.toString(), totalDeleted > 0 ? `${((deletionsByStatus.failed / totalDeleted) * 100).toFixed(1)}%` : '0%'],
                ['Cancelled', deletionsByStatus.cancelled.toString(), totalDeleted > 0 ? `${((deletionsByStatus.cancelled / totalDeleted) * 100).toFixed(1)}%` : '0%'],
                ['Skipped', deletionsByStatus.skipped.toString(), totalDeleted > 0 ? `${((deletionsByStatus.skipped / totalDeleted) * 100).toFixed(1)}%` : '0%'],
                ['Success (old)', deletionsByStatus.success.toString(), totalDeleted > 0 ? `${((deletionsByStatus.success / totalDeleted) * 100).toFixed(1)}%` : '0%']
              ]);
            
            if (deletionsByWorkflow.size > 0) {
              const topWorkflows = Array.from(deletionsByWorkflow.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
              
              summary.addHeading('üìã Top 10 Workflows by Deletions', 3)
                .addTable([
                  [{data: 'Workflow', header: true}, {data: 'Runs Deleted', header: true}],
                  ...topWorkflows.map(([name, count]) => [name, count.toString()])
                ]);
            }
            
            await summary.write();

  final-report:
    runs-on: ubuntu-latest
    needs: [analyze, cleanup-caches, cleanup-runs]
    if: always()
    
    steps:
      - name: üìä Generate Final Report
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const dryRun = '${{ inputs.dry_run }}' === 'true';
            const cleanupType = '${{ inputs.cleanup_type }}';
            
            async function withRetry(fn, maxRetries = 3) {
              for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                  return await fn();
                } catch (error) {
                  const isRateLimit = 
                    error.status === 429 || 
                    error.status === 403 ||
                    error.message?.toLowerCase().includes('rate limit') ||
                    error.message?.toLowerCase().includes('secondary rate limit');
                  
                  if (isRateLimit && attempt < maxRetries - 1) {
                    const backoff = 1000 * Math.pow(2, attempt) + Math.floor(Math.random() * 500);
                    console.log(`‚è≥ Rate limit hit, retrying in ${backoff}ms (attempt ${attempt + 1}/${maxRetries})...`);
                    await new Promise(resolve => setTimeout(resolve, backoff));
                    continue;
                  }
                  throw error;
                }
              }
            }
            
            console.log('üìä Generating final report...\n');
            
            const beforeSize = Number('${{ needs.analyze.outputs.total_cache_size || 0 }}') || 0;
            const beforeCount = Number('${{ needs.analyze.outputs.cache_count || 0 }}') || 0;
            const beforePercent = Number('${{ needs.analyze.outputs.usage_percent || 0 }}') || 0;
            
            let totalCacheSize = 0;
            let cacheCount = 0;
            const buildFrequency = new Map();
            const recentCutoff = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
            
            let page = 1;
            while (true) {
              const res = await withRetry(() =>
                github.rest.actions.getActionsCacheList({
                  owner,
                  repo,
                  per_page: 100,
                  page: page
                })
              );
              
              const caches = res.data.actions_caches;
              if (!caches || caches.length === 0) break;
              
              for (const cache of caches) {
                totalCacheSize += cache.size_in_bytes;
                cacheCount++;
                
                if (cache.key.startsWith('ccache-')) {
                  // ‚úÖ UPDATED: Support v4 format in final report
                  const isV4Format = cache.key.startsWith('ccache-ksun-v4-');
                  const isV3Format = cache.key.startsWith('ccache-ksun-v3-');
                  let device = null;
                  
                  if (isV4Format) {
                    const v4Match = cache.key.match(/^ccache-ksun-v4-([^-]+)-([^-]+)-([^-]+)-([^-]+)-([^-]+)(?:-([^-]+))?$/);
                    if (v4Match) {
                      device = v4Match[1];
                    }
                                    } else if (isV3Format) {
                    const v3Match = cache.key.match(/^ccache-ksun-v3-([^-]+-[\d.]+)-([A-Za-z0-9.-]+(?:-[A-Za-z0-9.-]+)*)-(clang-[A-Za-z0-9.-]+)-([A-Za-z0-9._-]+)(-stable)?$/);
                    if (v3Match) {
                      device = v3Match[4];
                    }
                  } else {
                    const legacy1 = cache.key.match(/^ccache-[^-]+-[\d.]+-[^-]+-clang-[^-]+-([^-]+)$/);
                    const legacy2 = cache.key.match(/^ccache-[^-]+-[\d.]+-[^-]+-([^-]+)$/);
                    const legacy3 = cache.key.match(/ccache-[^-]+-[^-]+-[^-]+-[^-]+-([^-]+)/);
                    
                    device = legacy1?.[1] || legacy2?.[1] || legacy3?.[1] || null;
                  }
                  
                  if (device && cache.last_accessed_at) {
                    const lastAccess = new Date(cache.last_accessed_at);
                    if (lastAccess > recentCutoff) {
                      buildFrequency.set(device, (buildFrequency.get(device) || 0) + 1);
                    }
                  }
                }
              }
              
              if (caches.length < 100) break;
              page++;
            }
            
            const totalSizeGB = (totalCacheSize / 1024 / 1024 / 1024).toFixed(2);
            const maxCacheSize = 10 * 1024 * 1024 * 1024;
            const usagePercent = ((totalCacheSize / maxCacheSize) * 100).toFixed(1);
            
            const summary = core.summary
              .addHeading('üìä Final Cleanup Report', 2)
              .addRaw(`\n**Report Date:** ${new Date().toISOString()}\n\n`)
              .addRaw(`**Cleanup Type:** ${cleanupType}\n`)
              .addRaw(`**Mode:** ${dryRun ? 'üîç Dry Run (Preview)' : '‚úÖ Live Cleanup'}\n\n`);
            
            summary.addHeading('üìà Current Cache Status', 3)
              .addTable([
                [{data: 'Metric', header: true}, {data: 'Value', header: true}],
                ['Total Cache Size', `${totalSizeGB} GB`],
                ['Total Cache Count', cacheCount.toString()],
                ['Usage Percentage', `${usagePercent}% of 10 GB`]
              ]);
            
            const hasValidBeforeData = beforeSize > 0 && beforeCount > 0 && beforePercent > 0;
            if (hasValidBeforeData && !dryRun && (cleanupType === 'cache_only' || cleanupType === 'full_cleanup')) {
              const sizeChange = beforeSize - totalSizeGB;
              const countChange = beforeCount - cacheCount;
              const percentChange = beforePercent - usagePercent;
              
              summary.addHeading('üîÑ Cleanup Impact', 3)
                .addTable([
                  [{data: 'Metric', header: true}, {data: 'Before', header: true}, {data: 'After', header: true}, {data: 'Change', header: true}],
                  ['Cache Size (GB)', beforeSize.toFixed(2), totalSizeGB, `${sizeChange > 0 ? '-' : '+'}${Math.abs(sizeChange).toFixed(2)} GB`],
                  ['Cache Count', beforeCount.toString(), cacheCount.toString(), `${countChange > 0 ? '-' : '+'}${Math.abs(countChange)}`],
                  ['Usage %', `${beforePercent}%`, `${usagePercent}%`, `${percentChange > 0 ? '-' : '+'}${Math.abs(percentChange).toFixed(1)}%`]
                ]);
              
              if (sizeChange > 0) {
                summary.addRaw(`\n‚úÖ **Successfully freed ${sizeChange.toFixed(2)} GB** (${((sizeChange / beforeSize) * 100).toFixed(1)}% reduction)\n\n`);
              }
            } else if (!hasValidBeforeData) {
              summary.addRaw(`\n> ‚ÑπÔ∏è **Note:** Before-cleanup data unavailable (analyze job may have been skipped)\n\n`);
            }
            
            if (buildFrequency.size > 0) {
              const topDevices = Array.from(buildFrequency.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 15);
              
              summary.addHeading('üî• Most Active Devices (Last 30 Days)', 3)
                .addTable([
                  [{data: 'Device', header: true}, {data: 'Build Activity', header: true}, {data: 'Status', header: true}],
                  ...topDevices.map(([device, count]) => [
                    device,
                    count.toString(),
                    count > 10 ? 'üî• Very Active' : count > 5 ? '‚úÖ Active' : 'üìä Moderate'
                  ])
                ]);
            }
            
            summary.addHeading('‚öôÔ∏è Cleanup Configuration', 3)
              .addTable([
                [{data: 'Setting', header: true}, {data: 'Value', header: true}],
                ['Cleanup Type', '${{ inputs.cleanup_type }}'],
                ['Device Filter', '${{ inputs.device_filter }}'],
                ['Cache Pattern', '${{ inputs.cache_pattern }}'],
                ['Cache Age Threshold', '${{ inputs.cache_age_days }} days'],
                ['Dry Run', '${{ inputs.dry_run }}'],
                ['Force Cleanup', '${{ inputs.force_cleanup }}']
              ]);
            
            summary.addHeading('üí° Recommendations', 3);
            
            if (parseFloat(usagePercent) > 90) {
              summary.addRaw(`\n‚ö†Ô∏è **Critical**: Cache usage is at ${usagePercent}%. Immediate cleanup required.\n`);
              summary.addRaw(`- Run full cleanup with \`force_cleanup: true\`\n`);
              summary.addRaw(`- Consider cleaning inactive devices\n`);
            } else if (parseFloat(usagePercent) > 75) {
              summary.addRaw(`\n‚ö†Ô∏è **Warning**: Cache usage is at ${usagePercent}%. Cleanup recommended soon.\n`);
              summary.addRaw(`- Schedule regular cleanups\n`);
              summary.addRaw(`- Review stale caches\n`);
            } else {
              summary.addRaw(`\n‚úÖ **Healthy**: Cache usage is at ${usagePercent}%. No immediate action needed.\n`);
              summary.addRaw(`- Continue monitoring\n`);
              summary.addRaw(`- Maintain regular cleanup schedule\n`);
            }
            
            const jobStatuses = {
              analyze: '${{ needs.analyze.result }}',
              cleanup_caches: '${{ needs.cleanup-caches.result }}',
              cleanup_runs: '${{ needs.cleanup-runs.result }}'
            };
            
            summary.addHeading('üìã Job Execution Status', 3)
              .addTable([
                [{data: 'Job', header: true}, {data: 'Status', header: true}],
                ['Analyze', jobStatuses.analyze === 'success' ? '‚úÖ Success' : 
                           jobStatuses.analyze === 'skipped' ? '‚è≠Ô∏è Skipped' : 
                           jobStatuses.analyze === 'failure' ? '‚ùå Failed' : '‚ö†Ô∏è ' + jobStatuses.analyze],
                ['Cleanup Caches', jobStatuses.cleanup_caches === 'success' ? '‚úÖ Success' : 
                                  jobStatuses.cleanup_caches === 'skipped' ? '‚è≠Ô∏è Skipped' : 
                                  jobStatuses.cleanup_caches === 'failure' ? '‚ùå Failed' : '‚ö†Ô∏è ' + jobStatuses.cleanup_caches],
                ['Cleanup Runs', jobStatuses.cleanup_runs === 'success' ? '‚úÖ Success' : 
                                jobStatuses.cleanup_runs === 'skipped' ? '‚è≠Ô∏è Skipped' : 
                                jobStatuses.cleanup_runs === 'failure' ? '‚ùå Failed' : '‚ö†Ô∏è ' + jobStatuses.cleanup_runs]
              ]);
            
            summary.addHeading('üîó Quick Actions', 3)
              .addRaw(`\n\`\`\`bash\n`)
              .addRaw(`# Run full cleanup (live)\n`)
              .addRaw(`gh workflow run cleanup.yml \\\n`)
              .addRaw(`  -f cleanup_type=full_cleanup \\\n`)
              .addRaw(`  -f dry_run=false\n\n`)
              .addRaw(`# Preview cleanup for specific device\n`)
              .addRaw(`gh workflow run cleanup.yml \\\n`)
              .addRaw(`  -f cleanup_type=cache_only \\\n`)
              .addRaw(`  -f device_filter=OP13 \\\n`)
              .addRaw(`  -f dry_run=true\n\n`)
              .addRaw(`# Clean stale caches only\n`)
              .addRaw(`gh workflow run cleanup.yml \\\n`)
              .addRaw(`  -f cleanup_type=cache_only \\\n`)
              .addRaw(`  -f cache_pattern=ccache_stale \\\n`)
              .addRaw(`  -f cache_age_days=14 \\\n`)
              .addRaw(`  -f dry_run=false\n`)
              .addRaw(`\`\`\`\n`);
            
            await summary.write();
            
            console.log('\n‚úÖ Final report generated successfully');
