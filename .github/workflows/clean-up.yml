name: Cleanup CCache üßπ

on:
  workflow_dispatch:
    inputs:
      cleanup_type:
        type: choice
        description: 'Cleanup target'
        required: true
        default: 'cache_only'
        options:
          - cache_only          # Only clean caches
          - runs_only           # Only clean workflow runs
          - full_cleanup        # Both caches and runs
          - analyze_only        # Just analyze, don't delete
      
      device_filter:
        type: choice
        description: 'Device cache to clean'
        required: false
        default: 'ALL'
        options:
          - ALL
          # Kernel Versions
          - android15-6.6
          - android14-6.1
          - android14-5.15
          - android13-5.15
          - android13-5.10
          - android12-5.10
          # OnePlus Phones
          - OP13-CPH
          - OP13-PJZ
          - OP13r
          - OP13S
          - OP13T
          - OP12
          - OP12r
          - OP11
          - OP11r
          - OP10pro
          - OP10t
          # OnePlus Nord Series
          - OP-Nord-5
          - OP-NORD-4
          - OP-NORD-4-CE
          - OP-NORD-CE4-LITE
          # OnePlus Ace Series
          - OP-ACE-5-PRO
          - OP-ACE-5
          - OP-ACE-3-PRO
          - OP-ACE-3V
          - OP-ACE-2-PRO
          - OP-ACE-2
          # OnePlus Tablets & Others
          - OP-OPEN
          - OP-PAD-3
          - OP-PAD-2-PRO
          - OP-PAD-2
          - OP-PAD-PRO
      
      cache_pattern:
        type: choice
        description: 'Cache type to clean'
        required: false
        default: 'all_caches'
        options:
          - all_caches          # All cache types
          - ccache_only         # Only ccache (kernel builds)
          - ccache_stale        # Only stale ccache (>14 days since last access)
          - apt_only            # Only apt packages
          - kernel_only         # Only kernel-related caches (excludes apt)
          - old_only            # Only caches older than N days (by creation)
      
      cache_age_days:
        description: 'Delete caches older than N days (by creation date)'
        required: false
        default: '7'
      
      keep_recent_runs:
        description: 'Keep N most recent successful runs'
        required: false
        default: '3'
      
      days_to_keep:
        description: 'Keep runs from last N days'
        required: false
        default: '7'
      
      dry_run:
        description: 'Dry run (show what would be deleted)'
        required: false
        type: boolean
        default: false
      
      force_cleanup:
        description: 'Force cleanup even if usage is low'
        required: false
        type: boolean
        default: false

permissions:
  actions: write
  contents: read

jobs:
  analyze:
    runs-on: ubuntu-latest
    outputs:
      should_cleanup: ${{ steps.analysis.outputs.should_cleanup }}
      total_cache_size: ${{ steps.analysis.outputs.total_size }}
      cache_count: ${{ steps.analysis.outputs.cache_count }}
      usage_percent: ${{ steps.analysis.outputs.usage_percent }}
      ccache_count: ${{ steps.analysis.outputs.ccache_count }}
      ccache_size: ${{ steps.analysis.outputs.ccache_size }}
    steps:
      - name: üìä Analyze Repository Health
        id: analysis
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const forceCleanup = '${{ inputs.force_cleanup }}' === 'true';
            
            console.log('üîç Analyzing repository cache health...\n');
            
            let page = 1;
            let totalCacheSize = 0;
            let cacheCount = 0;
            let oldestCache = null;
            let newestCache = null;
            
            const cachesByType = {
              ccache: { size: 0, count: 0 },
              apt: { size: 0, count: 0 },
              kernel: { size: 0, count: 0 },
              other: { size: 0, count: 0 }
            };
            
            const cachesByDevice = new Map();
            const cacheAgeDistribution = {
              fresh: 0,      // < 7 days
              recent: 0,     // 7-14 days
              old: 0,        // 14-30 days
              stale: 0       // > 30 days
            };
            
            const lastAccessDistribution = {
              active: 0,     // < 7 days
              recent: 0,     // 7-14 days
              dormant: 0,    // 14-30 days
              stale: 0       // > 30 days
            };
            
            const cacheKeyVersions = {
              v3: 0,    // New format: ccache-ksun-v3-...
              legacy: 0 // Old format: ccache-...
            };
            
            // Collect all cache data
            while (true) {
              const res = await github.rest.actions.getActionsCacheList({
                owner,
                repo,
                per_page: 100,
                page: page
              });
              
              const caches = res.data.actions_caches;
              if (!caches || caches.length === 0) break;
              
              for (const cache of caches) {
                totalCacheSize += cache.size_in_bytes;
                cacheCount++;
                
                const cacheDate = new Date(cache.created_at);
                const lastAccessDate = new Date(cache.last_accessed_at || cache.created_at);
                const ageDays = Math.floor((new Date() - cacheDate) / (1000 * 60 * 60 * 24));
                const accessAgeDays = Math.floor((new Date() - lastAccessDate) / (1000 * 60 * 60 * 24));
                
                // Age distribution (by creation)
                if (ageDays < 7) cacheAgeDistribution.fresh++;
                else if (ageDays < 14) cacheAgeDistribution.recent++;
                else if (ageDays < 30) cacheAgeDistribution.old++;
                else cacheAgeDistribution.stale++;
                
                // Last access distribution
                if (accessAgeDays < 7) lastAccessDistribution.active++;
                else if (accessAgeDays < 14) lastAccessDistribution.recent++;
                else if (accessAgeDays < 30) lastAccessDistribution.dormant++;
                else lastAccessDistribution.stale++;
                
                if (!oldestCache || cacheDate < new Date(oldestCache.created_at)) {
                  oldestCache = cache;
                }
                if (!newestCache || cacheDate > new Date(newestCache.created_at)) {
                  newestCache = cache;
                }
                
                // Categorize by type
                if (cache.key.startsWith('ccache-')) {
                  cachesByType.ccache.size += cache.size_in_bytes;
                  cachesByType.ccache.count++;
                  
                  // Track cache key versions
                  const isV3Format = cache.key.startsWith('ccache-ksun-v3-');
                  if (isV3Format) {
                    cacheKeyVersions.v3++;
                  } else {
                    cacheKeyVersions.legacy++;
                  }
                  
                  // Extract device name - ROBUST PARSING
                  let device = null;
                  let osVersion = null;
                  
                  if (isV3Format) {
                    // v3 format: ccache-ksun-v3-android15-6.6-OOS15-clang-r123456-OP13[-stable]
                    // Pattern: ccache-ksun-v3-<kernel>-<os>-<clang>-<device>[-stable]
                    const v3Match = cache.key.match(/^ccache-ksun-v3-([^-]+-[\d.]+)-([^-]+)-(clang-[^-]+)-([^-]+)(-stable)?$/);
                    if (v3Match) {
                      // v3Match[1] = kernel (android15-6.6)
                      // v3Match[2] = os (OOS15)
                      // v3Match[3] = clang (clang-r123456)
                      // v3Match[4] = device (OP13)
                      osVersion = v3Match[2];
                      device = v3Match[4];
                    }
                  } else {
                    // Legacy format - try multiple patterns
                    // Pattern 1: ccache-android15-6.6-OOS15-clang-r123456-OP13
                    const legacy1 = cache.key.match(/^ccache-[^-]+-[\d.]+-[^-]+-clang-[^-]+-([^-]+)$/);
                    // Pattern 2: ccache-android15-6.6-OOS15-OP13 (no clang)
                    const legacy2 = cache.key.match(/^ccache-[^-]+-[\d.]+-[^-]+-([^-]+)$/);
                    // Pattern 3: Any trailing component after multiple dashes
                    const legacy3 = cache.key.match(/ccache-[^-]+-[^-]+-[^-]+-[^-]+-([^-]+)/);
                    
                    device = legacy1?.[1] || legacy2?.[1] || legacy3?.[1] || null;
                  }
                  
                  if (device) {
                    if (!cachesByDevice.has(device)) {
                      cachesByDevice.set(device, { 
                        size: 0, 
                        count: 0,
                        lastAccessed: cache.last_accessed_at,
                        oldestCache: ageDays,
                        newestCache: ageDays,
                        oldestAccess: accessAgeDays,
                        newestAccess: accessAgeDays,
                        osVersions: new Set(),
                        v3Count: 0,
                        legacyCount: 0
                      });
                    }
                    const deviceData = cachesByDevice.get(device);
                    deviceData.size += cache.size_in_bytes;
                    deviceData.count++;
                    if (osVersion) deviceData.osVersions.add(osVersion);
                    deviceData.oldestCache = Math.max(deviceData.oldestCache, ageDays);
                    deviceData.newestCache = Math.min(deviceData.newestCache, ageDays);
                    deviceData.oldestAccess = Math.max(deviceData.oldestAccess, accessAgeDays);
                    deviceData.newestAccess = Math.min(deviceData.newestAccess, accessAgeDays);
                    
                    if (isV3Format) {
                      deviceData.v3Count++;
                    } else {
                      deviceData.legacyCount++;
                    }
                    
                    if (new Date(cache.last_accessed_at) > new Date(deviceData.lastAccessed)) {
                      deviceData.lastAccessed = cache.last_accessed_at;
                    }
                  }
                } else if (cache.key.includes('apt')) {
                  cachesByType.apt.size += cache.size_in_bytes;
                  cachesByType.apt.count++;
                } else if (cache.key.includes('kernel') || cache.key.includes('android') || cache.key.includes('gki')) {
                  cachesByType.kernel.size += cache.size_in_bytes;
                  cachesByType.kernel.count++;
                } else {
                  cachesByType.other.size += cache.size_in_bytes;
                  cachesByType.other.count++;
                }
              }
              
              if (caches.length < 100) break;
              page++;
            }
            
            // Calculate metrics
            const totalGB = (totalCacheSize / 1024 / 1024 / 1024).toFixed(2);
            const limit = 10; // 10 GB GitHub limit
            const usagePercent = totalCacheSize > 0 ? ((totalCacheSize / (limit * 1024 * 1024 * 1024)) * 100).toFixed(1) : '0.0';
            
            // Determine if cleanup is needed
            const shouldCleanup = forceCleanup || parseFloat(usagePercent) > 75;
            
            // Health status
            let healthEmoji = 'üü¢';
            let healthStatus = 'Healthy';
            if (parseFloat(usagePercent) > 90) {
              healthEmoji = 'üî¥';
              healthStatus = 'Critical';
            } else if (parseFloat(usagePercent) > 75) {
              healthEmoji = 'üü°';
              healthStatus = 'Warning';
            }
            
            // Output for next jobs
            core.setOutput('should_cleanup', shouldCleanup.toString());
            core.setOutput('total_size', totalCacheSize.toString());
            core.setOutput('cache_count', cacheCount.toString());
            core.setOutput('usage_percent', usagePercent);
            core.setOutput('ccache_count', cachesByType.ccache.count.toString());
            core.setOutput('ccache_size', cachesByType.ccache.size.toString());
            
            // Generate detailed summary
            let summary = core.summary
              .addHeading(`${healthEmoji} Cache Health Analysis - ${healthStatus}`)
              .addRaw(`\n### üìä Overall Statistics\n\n`)
              .addTable([
                [{data: 'Metric', header: true}, {data: 'Value', header: true}],
                ['Total Caches', cacheCount.toString()],
                ['Total Size', `${totalGB} GB`],
                ['Limit', `${limit} GB`],
                ['Usage', `${usagePercent}%`],
                ['Available', `${(limit - parseFloat(totalGB)).toFixed(2)} GB`],
                ['Status', healthStatus]
              ]);
            
            // Cache breakdown by type
            summary.addRaw(`\n### üóÇÔ∏è Cache Breakdown by Type\n\n`)
              .addTable([
                [{data: 'Type', header: true}, {data: 'Count', header: true}, {data: 'Size (GB)', header: true}, {data: 'Percentage', header: true}],
                ['ccache (Kernel Builds)', 
                  cachesByType.ccache.count.toString(),
                  (cachesByType.ccache.size / 1024 / 1024 / 1024).toFixed(2),
                  totalCacheSize > 0 ? `${((cachesByType.ccache.size / totalCacheSize) * 100).toFixed(1)}%` : '0%'
                ],
                ['Kernel-related',
                  cachesByType.kernel.count.toString(),
                  (cachesByType.kernel.size / 1024 / 1024 / 1024).toFixed(2),
                  totalCacheSize > 0 ? `${((cachesByType.kernel.size / totalCacheSize) * 100).toFixed(1)}%` : '0%'
                ],
                ['APT Packages',
                  cachesByType.apt.count.toString(),
                  (cachesByType.apt.size / 1024 / 1024 / 1024).toFixed(2),
                  totalCacheSize > 0 ? `${((cachesByType.apt.size / totalCacheSize) * 100).toFixed(1)}%` : '0%'
                ],
                ['Other',
                  cachesByType.other.count.toString(),
                  (cachesByType.other.size / 1024 / 1024 / 1024).toFixed(2),
                  totalCacheSize > 0 ? `${((cachesByType.other.size / totalCacheSize) * 100).toFixed(1)}%` : '0%'
                ]
              ]);
            
            // Cache key version distribution
            if (cachesByType.ccache.count > 0) {
              const totalCcache = cacheKeyVersions.v3 + cacheKeyVersions.legacy;
              summary.addRaw(`\n### üîë Cache Key Versions\n\n`)
                .addTable([
                  [{data: 'Version', header: true}, {data: 'Count', header: true}, {data: 'Percentage', header: true}],
                  ['v3 (New Format)', cacheKeyVersions.v3.toString(), totalCcache > 0 ? `${((cacheKeyVersions.v3 / totalCcache) * 100).toFixed(1)}%` : '0%'],
                  ['Legacy (Old Format)', cacheKeyVersions.legacy.toString(), totalCcache > 0 ? `${((cacheKeyVersions.legacy / totalCcache) * 100).toFixed(1)}%` : '0%']
                ]);
              
              if (cacheKeyVersions.legacy > 0) {
                const legacySize = totalCcache > 0 ? (cacheKeyVersions.legacy / totalCcache) * cachesByType.ccache.size : 0;
                const legacySizeGB = (legacySize / 1024 / 1024 / 1024).toFixed(2);
                summary.addRaw(`\n‚ö†Ô∏è **${cacheKeyVersions.legacy} legacy caches detected** (~${legacySizeGB} GB)\n`)
                  .addRaw(`- These use the old cache key format\n`)
                  .addRaw(`- Consider cleaning to free space for new format\n`)
                  .addRaw(`- Run with \`cache_pattern: old_only\` to target legacy caches\n`);
              }
            }
            
            // ccache-specific statistics
            if (cachesByType.ccache.count > 0) {
              const avgCcacheSize = cachesByType.ccache.size / cachesByType.ccache.count;
              const avgCcacheSizeMB = (avgCcacheSize / 1024 / 1024).toFixed(2);
              const ccachePercent = totalCacheSize > 0 ? ((cachesByType.ccache.size / totalCacheSize) * 100).toFixed(1) : '0';
              
              summary.addRaw(`\n### ‚ö° ccache Statistics\n\n`)
                .addTable([
                  [{data: 'Metric', header: true}, {data: 'Value', header: true}],
                  ['Total ccache Entries', cachesByType.ccache.count.toString()],
                  ['Total ccache Size', `${(cachesByType.ccache.size / 1024 / 1024 / 1024).toFixed(2)} GB`],
                  ['Average Cache Size', `${avgCcacheSizeMB} MB`],
                  ['Percentage of Total', `${ccachePercent}%`],
                  ['Unique Devices', cachesByDevice.size.toString()]
                ]);
              
              // ccache recommendations
              if (parseFloat(ccachePercent) > 80) {
                summary.addRaw(`\n‚ö†Ô∏è **ccache dominates storage** (${ccachePercent}%)\n`)
                  .addRaw(`- Consider reducing \`CCACHE_MAXSIZE\` in build workflow\n`)
                  .addRaw(`- Clean stale device caches not actively built\n`)
                  .addRaw(`- Use \`clean: true\` option occasionally to verify builds\n`);
              }
            }
            
            // Age distribution (by creation)
            summary.addRaw(`\n### üìÖ Cache Age Distribution (by Creation Date)\n\n`)
              .addTable([
                [{data: 'Age Range', header: true}, {data: 'Count', header: true}, {data: 'Percentage', header: true}],
                ['Fresh (< 7 days)', cacheAgeDistribution.fresh.toString(), cacheCount > 0 ? `${((cacheAgeDistribution.fresh / cacheCount) * 100).toFixed(1)}%` : '0%'],
                ['Recent (7-14 days)', cacheAgeDistribution.recent.toString(), cacheCount > 0 ? `${((cacheAgeDistribution.recent / cacheCount) * 100).toFixed(1)}%` : '0%'],
                ['Old (14-30 days)', cacheAgeDistribution.old.toString(), cacheCount > 0 ? `${((cacheAgeDistribution.old / cacheCount) * 100).toFixed(1)}%` : '0%'],
                ['Stale (> 30 days)', cacheAgeDistribution.stale.toString(), cacheCount > 0 ? `${((cacheAgeDistribution.stale / cacheCount) * 100).toFixed(1)}%` : '0%']
              ]);
            
            // Last access distribution
            summary.addRaw(`\n### üîÑ Cache Activity (by Last Access)\n\n`)
              .addTable([
                [{data: 'Activity Level', header: true}, {data: 'Count', header: true}, {data: 'Percentage', header: true}],
                ['Active (< 7 days)', lastAccessDistribution.active.toString(), cacheCount > 0 ? `${((lastAccessDistribution.active / cacheCount) * 100).toFixed(1)}%` : '0%'],
                ['Recent (7-14 days)', lastAccessDistribution.recent.toString(), cacheCount > 0 ? `${((lastAccessDistribution.recent / cacheCount) * 100).toFixed(1)}%` : '0%'],
                ['Dormant (14-30 days)', lastAccessDistribution.dormant.toString(), cacheCount > 0 ? `${((lastAccessDistribution.dormant / cacheCount) * 100).toFixed(1)}%` : '0%'],
                ['Stale (> 30 days)', lastAccessDistribution.stale.toString(), cacheCount > 0 ? `${((lastAccessDistribution.stale / cacheCount) * 100).toFixed(1)}%` : '0%']
              ]);
            
            // Top devices by cache size
            if (cachesByDevice.size > 0) {
              const topDevices = Array.from(cachesByDevice.entries())
                .sort((a, b) => b[1].size - a[1].size)
                .slice(0, 15);
              
              summary.addRaw(`\n### üì± Top 15 Devices by Cache Size\n\n`)
                .addTable([
                  [{data: 'Device', header: true}, {data: 'Caches', header: true}, {data: 'Size (GB)', header: true}, {data: 'Created Age', header: true}, {data: 'Access Age', header: true}, {data: 'v3/Legacy', header: true}],
                  ...topDevices.map(([device, data]) => [
                    device,
                    data.count.toString(),
                    (data.size / 1024 / 1024 / 1024).toFixed(2),
                    `${data.newestCache}-${data.oldestCache}d`,
                    `${data.newestAccess}-${data.oldestAccess}d`,
                    `${data.v3Count}/${data.legacyCount}`
                  ])
                ]);
              
              // Identify inactive devices (by last access)
              const now = new Date();
              const inactiveThreshold = 30; // days
              const inactiveDevices = Array.from(cachesByDevice.entries())
                .filter(([_, data]) => {
                  const daysSinceAccess = Math.floor((now - new Date(data.lastAccessed)) / (1000 * 60 * 60 * 24));
                  return daysSinceAccess > inactiveThreshold;
                })
                .sort((a, b) => b[1].size - a[1].size);
              
              if (inactiveDevices.length > 0) {
                summary.addRaw(`\n### üö´ Inactive Devices (Not accessed in ${inactiveThreshold}+ days)\n\n`)
                  .addTable([
                    [{data: 'Device', header: true}, {data: 'Size (GB)', header: true}, {data: 'Days Since Access', header: true}, {data: 'Legacy Caches', header: true}],
                    ...inactiveDevices.slice(0, 10).map(([device, data]) => [
                      device,
                      (data.size / 1024 / 1024 / 1024).toFixed(2),
                      Math.floor((now - new Date(data.lastAccessed)) / (1000 * 60 * 60 * 24)).toString(),
                      data.legacyCount.toString()
                    ])
                  ]);
                
                const inactiveSizeGB = inactiveDevices.reduce((sum, [_, data]) => sum + data.size, 0) / 1024 / 1024 / 1024;
                summary.addRaw(`\nüí° **Potential savings:** ${inactiveSizeGB.toFixed(2)} GB by cleaning inactive devices\n`);
              }
            }
            
            // Age information
            if (oldestCache && newestCache) {
              const oldestDate = new Date(oldestCache.created_at);
              const newestDate = new Date(newestCache.created_at);
              const daysDiff = Math.floor((newestDate - oldestDate) / (1000 * 60 * 60 * 24));
              
              summary.addRaw(`\n### üìÖ Cache Age Information\n\n`)
                .addTable([
                  [{data: 'Metric', header: true}, {data: 'Value', header: true}],
                  ['Oldest Cache', oldestDate.toISOString().split('T')[0]],
                  ['Newest Cache', newestDate.toISOString().split('T')[0]],
                  ['Age Range', `${daysDiff} days`]
                ]);
            }
            
            // Recommendations
            summary.addRaw(`\n### üí° Recommendations\n\n`);
            
            if (parseFloat(usagePercent) > 90) {
              summary.addRaw(`- üî¥ **URGENT:** Cache usage is critical (${usagePercent}%)\n`)
                .addRaw(`- Run cleanup immediately with \`device_filter: ALL\`\n`)
                .addRaw(`- Consider cleaning old device caches\n`)
                .addRaw(`- Review ccache size limits in build workflows\n`);
            } else if (parseFloat(usagePercent) > 75) {
              summary.addRaw(`- üü° **WARNING:** Cache usage is high (${usagePercent}%)\n`)
                .addRaw(`- Schedule cleanup soon\n`)
                .addRaw(`- Consider targeting specific devices\n`);
            } else {
              summary.addRaw(`- üü¢ Cache usage is healthy (${usagePercent}%)\n`)
                .addRaw(`- Regular weekly cleanup recommended\n`)
                .addRaw(`- No immediate action required\n`);
            }
            
            // Stale cache recommendations (by last access)
            if (lastAccessDistribution.stale > 0) {
              const staleSizeEstimate = cacheCount > 0 ? (lastAccessDistribution.stale / cacheCount) * totalCacheSize : 0;
              const staleSizeGB = (staleSizeEstimate / 1024 / 1024 / 1024).toFixed(2);
              summary.addRaw(`\n- üì¶ **${lastAccessDistribution.stale} stale caches** (>30 days since access)\n`)
                .addRaw(`- Estimated size: ~${staleSizeGB} GB\n`)
                .addRaw(`- Run with \`cache_pattern: ccache_stale\` to clean\n`);
            }
            
            // Legacy cache cleanup recommendation
            if (cacheKeyVersions.legacy > 0) {
              summary.addRaw(`\n- üîÑ **${cacheKeyVersions.legacy} legacy format caches** detected\n`)
                .addRaw(`- These can be safely cleaned as builds now use v3 format\n`)
                .addRaw(`- Run with \`cache_pattern: old_only\` to target legacy caches\n`);
            }
            
            if (shouldCleanup && !forceCleanup) {
              summary.addRaw(`\n‚ö†Ô∏è **Automatic cleanup will proceed** (usage > 75%)\n`);
            } else if (forceCleanup) {
              summary.addRaw(`\n‚ö° **Force cleanup enabled** - proceeding regardless of usage\n`);
            }
            
            summary.write();
            
            console.log(`\n‚úÖ Analysis complete:`);
            console.log(`   - Total: ${totalGB} GB (${usagePercent}%)`);
            console.log(`   - Caches: ${cacheCount}`);
            console.log(`   - ccache: ${cachesByType.ccache.count} (${(cachesByType.ccache.size / 1024 / 1024 / 1024).toFixed(2)} GB)`);
            console.log(`   - v3 format: ${cacheKeyVersions.v3}, Legacy: ${cacheKeyVersions.legacy}`);
            console.log(`   - Devices: ${cachesByDevice.size}`);
            console.log(`   - Cleanup needed: ${shouldCleanup}`);

  cleanup-caches:
    runs-on: ubuntu-latest
    needs: analyze
    if: |
      always() &&
      (inputs.cleanup_type == 'cache_only' || inputs.cleanup_type == 'full_cleanup') &&
      (inputs.cleanup_type != 'analyze_only')
    
    steps:
      - name: üóëÔ∏è Smart Cache Cleanup
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const deviceFilter = '${{ inputs.device_filter }}';
            const cachePattern = '${{ inputs.cache_pattern }}';
            const dryRun = '${{ inputs.dry_run }}' === 'true';
            const cacheAgeDays = parseInt('${{ inputs.cache_age_days }}');
            const shouldCleanup = '${{ needs.analyze.outputs.should_cleanup }}' === 'true';
            const forceCleanup = '${{ inputs.force_cleanup }}' === 'true';
            
            console.log(`üéØ Configuration:`);
            console.log(`   - Device Filter: ${deviceFilter}`);
            console.log(`   - Cache Pattern: ${cachePattern}`);
            console.log(`   - Age Threshold: ${cacheAgeDays} days`);
            console.log(`   - Dry Run: ${dryRun}`);
            console.log(`   - Should Cleanup: ${shouldCleanup}`);
            console.log(`   - Force Cleanup: ${forceCleanup}\n`);
            
            // Check if we should proceed
            if (!shouldCleanup && !forceCleanup && !dryRun) {
              const usage = '${{ needs.analyze.outputs.usage_percent }}';
              console.log('‚ÑπÔ∏è Cache usage is healthy, skipping cleanup');
              console.log('üí° Use force_cleanup=true to cleanup anyway');
              core.summary
                .addHeading('‚ÑπÔ∏è Cleanup Skipped')
                .addRaw(`Cache usage is healthy (${usage}%)\n\n`)
                .addRaw('No cleanup needed at this time.\n')
                .write();
              return;
            }
            
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - cacheAgeDays);
            
            // For stale ccache pattern, use 14 days since last access
            const staleCutoffDate = new Date();
            staleCutoffDate.setDate(staleCutoffDate.getDate() - 14);
            
            // For stable key protection, use 30 days
            const veryStaleCutoffDate = new Date();
            veryStaleCutoffDate.setDate(veryStaleCutoffDate.getDate() - 30);
            
            let totalDeleted = 0;
            let totalSize = 0;
            let page = 1;
            const deletedCaches = [];
            const skippedCaches = [];
            
            // Track statistics by category
            const deletionStats = {
              ccache: { count: 0, size: 0, v3: 0, legacy: 0, stable: 0 },
              apt: { count: 0, size: 0 },
              kernel: { count: 0, size: 0 },
              other: { count: 0, size: 0 }
            };
            
            // Helper function to check if cache should be deleted
            function shouldDeleteCache(cache) {
              const cacheKey = cache.key;
              const cacheDate = new Date(cache.created_at);
              const lastAccessDate = new Date(cache.last_accessed_at || cache.created_at);
              const ageDays = Math.floor((new Date() - cacheDate) / (1000 * 60 * 60 * 24));
              const accessAgeDays = Math.floor((new Date() - lastAccessDate) / (1000 * 60 * 60 * 24));
              
              // Check if it's a v3 format and stable key
              const isV3Format = cacheKey.startsWith('ccache-ksun-v3-');
              const isStableKey = cacheKey.endsWith('-stable');
              
              // Extract device from cache key - ROBUST PARSING
              let device = null;
              
              if (isV3Format) {
                // v3 format: ccache-ksun-v3-android15-6.6-OOS15-clang-r123456-OP13[-stable]
                const v3Match = cacheKey.match(/^ccache-ksun-v3-([^-]+-[\d.]+)-([^-]+)-(clang-[^-]+)-([^-]+)(-stable)?$/);
                if (v3Match) {
                  device = v3Match[4]; // OP13
                }
              } else if (cacheKey.startsWith('ccache-')) {
                // Legacy format - try multiple patterns
                const legacy1 = cacheKey.match(/^ccache-[^-]+-[\d.]+-[^-]+-clang-[^-]+-([^-]+)$/);
                const legacy2 = cacheKey.match(/^ccache-[^-]+-[\d.]+-[^-]+-([^-]+)$/);
                const legacy3 = cacheKey.match(/ccache-[^-]+-[^-]+-[^-]+-[^-]+-([^-]+)/);
                
                device = legacy1?.[1] || legacy2?.[1] || legacy3?.[1] || null;
              }
              
              // Device filter logic
              const deviceMatchesFilter = 
                deviceFilter === 'ALL' ||
                (device && device === deviceFilter) ||
                cacheKey.includes(deviceFilter) ||
                cacheKey.includes(`-${deviceFilter}-`);
              
              if (!deviceMatchesFilter) {
                return { delete: false, reason: 'device_filter' };
              }
              
              // Age filter for 'old_only' pattern (by creation date)
              if (cachePattern === 'old_only' && cacheDate >= cutoffDate) {
                return { delete: false, reason: 'too_new' };
              }
              
              // Cache pattern logic
              let patternMatch = false;
              let category = 'other';
              
              switch (cachePattern) {
                case 'ccache_only':
                  patternMatch = cacheKey.startsWith('ccache-');
                  category = 'ccache';
                  break;
                  
                case 'ccache_stale':
                  // Use last access date for staleness, not creation date
                  if (cacheKey.startsWith('ccache-')) {
                    category = 'ccache';
                    
                    // Check if truly stale (not accessed in 14+ days)
                    if (lastAccessDate < staleCutoffDate) {
                      // Protect v3 stable keys unless VERY stale (30+ days) or forced
                      if (isV3Format && isStableKey && lastAccessDate >= veryStaleCutoffDate && !forceCleanup) {
                        return { delete: false, reason: 'stable_recent' };
                      }
                      
                      // Prefer deleting legacy caches first
                      patternMatch = true;
                    } else {
                      return { delete: false, reason: 'recently_accessed' };
                    }
                  }
                  break;
                  
                case 'apt_only':
                  patternMatch = cacheKey.includes('apt-cache') || cacheKey.includes('apt-');
                  category = 'apt';
                  break;
                  
                case 'kernel_only':
                  // Include ccache, kernel, android, gki but exclude apt
                  patternMatch = (cacheKey.startsWith('ccache-') || 
                                 cacheKey.includes('kernel') || 
                                 cacheKey.includes('android') ||
                                 cacheKey.includes('gki')) && 
                                 !cacheKey.includes('apt');
                  
                  if (cacheKey.startsWith('ccache-')) category = 'ccache';
                  else category = 'kernel';
                  break;
                  
                case 'old_only':
                  // Based on creation date
                  patternMatch = cacheDate < cutoffDate;
                  if (cacheKey.startsWith('ccache-')) category = 'ccache';
                  else if (cacheKey.includes('apt')) category = 'apt';
                  else if (cacheKey.includes('kernel') || cacheKey.includes('android') || cacheKey.includes('gki')) category = 'kernel';
                  break;
                  
                case 'all_caches':
                default:
                  patternMatch = true;
                  if (cacheKey.startsWith('ccache-')) category = 'ccache';
                  else if (cacheKey.includes('apt')) category = 'apt';
                  else if (cacheKey.includes('kernel') || cacheKey.includes('android') || cacheKey.includes('gki')) category = 'kernel';
              }
              
              return { 
                delete: patternMatch, 
                reason: patternMatch ? 'match' : 'pattern_mismatch',
                category: category,
                isStable: isStableKey,
                isV3: isV3Format,
                device: device,
                accessAgeDays: accessAgeDays
              };
            }
            
            // Fetch and process caches
            console.log('üîç Scanning caches...\n');
            
            while (true) {
              const res = await github.rest.actions.getActionsCacheList({
                owner,
                repo,
                per_page: 100,
                page: page
              });
              
              const caches = res.data.actions_caches;
              if (!caches || caches.length === 0) break;
              
              for (const cache of caches) {
                const decision = shouldDeleteCache(cache);
                const sizeMB = (cache.size_in_bytes / 1024 / 1024).toFixed(2);
                const createdAgeDays = Math.floor((new Date() - new Date(cache.created_at)) / (1000 * 60 * 60 * 24));
                
                if (decision.delete) {
                  deletedCaches.push({
                    key: cache.key,
                    size: sizeMB,
                    sizeBytes: cache.size_in_bytes,
                    createdAge: createdAgeDays,
                    accessAge: decision.accessAgeDays,
                    created: cache.created_at,
                    accessed: cache.last_accessed_at,
                    id: cache.id,
                    category: decision.category,
                    isV3: decision.isV3,
                    isStable: decision.isStable,
                    device: decision.device
                  });
                  
                  const format = decision.isV3 ? 'v3' : 'legacy';
                  const stable = decision.isStable ? ' (stable)' : '';
                  
                  if (dryRun) {
                    console.log(`üîç Would delete: ${cache.key}`);
                    console.log(`   Size: ${sizeMB} MB | Created: ${createdAgeDays}d ago | Accessed: ${decision.accessAgeDays}d ago | Type: ${decision.category} | Format: ${format}${stable}`);
                  } else {
                    console.log(`üóëÔ∏è Deleting: ${cache.key}`);
                    console.log(`   Size: ${sizeMB} MB | Created: ${createdAgeDays}d ago | Accessed: ${decision.accessAgeDays}d ago | Type: ${decision.category} | Format: ${format}${stable}`);
                    
                    try {
                      await github.rest.actions.deleteActionsCacheById({
                        owner,
                        repo,
                        cache_id: cache.id
                      });
                      totalDeleted++;
                      totalSize += cache.size_in_bytes;
                      
                      // Update category stats
                      deletionStats[decision.category].count++;
                      deletionStats[decision.category].size += cache.size_in_bytes;
                      
                      if (decision.category === 'ccache') {
                        if (decision.isV3) {
                          deletionStats.ccache.v3++;
                        } else {
                          deletionStats.ccache.legacy++;
                        }
                        if (decision.isStable) {
                          deletionStats.ccache.stable++;
                        }
                      }
                    } catch (error) {
                      console.log(`   ‚ö†Ô∏è Failed: ${error.message}`);
                      skippedCaches.push({
                        key: cache.key,
                        reason: error.message
                      });
                    }
                  }
                } else if (decision.reason === 'stable_recent') {
                  console.log(`üîí Protecting stable v3 cache: ${cache.key} (accessed ${decision.accessAgeDays}d ago)`);
                }
              }
              
              if (caches.length < 100) break;
              page++;
            }
            
            const sizeMB = (totalSize / 1024 / 1024).toFixed(2);
            const sizeGB = (totalSize / 1024 / 1024 / 1024).toFixed(2);
            
            console.log(`\n‚úÖ ${dryRun ? 'Would delete' : 'Deleted'} ${totalDeleted} caches`);
            console.log(`üìä Space ${dryRun ? 'would be' : ''} freed: ${sizeMB} MB (${sizeGB} GB)`);
            
            // Generate detailed summary
            let summary = core.summary
              .addHeading(`üßπ Cache Cleanup ${dryRun ? 'Preview' : 'Summary'}`)
              .addTable([
                [{data: 'Metric', header: true}, {data: 'Value', header: true}],
                ['Caches ' + (dryRun ? 'to Delete' : 'Deleted'), totalDeleted.toString()],
                ['Space ' + (dryRun ? 'to Free' : 'Freed'), `${sizeMB} MB (${sizeGB} GB)`],
                ['Device Filter', deviceFilter],
                ['Cache Pattern', cachePattern],
                ['Age Threshold', `${cacheAgeDays} days`]
              ]);
            
            // Deletion breakdown by type
            if (totalDeleted > 0 || dryRun) {
              summary.addHeading('üìä Deletion Breakdown by Type', 3)
                .addTable([
                  [{data: 'Type', header: true}, {data: 'Count', header: true}, {data: 'Size (GB)', header: true}, {data: 'Percentage', header: true}],
                  ['ccache', 
                    deletionStats.ccache.count.toString(),
                    (deletionStats.ccache.size / 1024 / 1024 / 1024).toFixed(2),
                    totalSize > 0 ? `${((deletionStats.ccache.size / totalSize) * 100).toFixed(1)}%` : '0%'
                  ],
                  ['Kernel-related',
                    deletionStats.kernel.count.toString(),
                    (deletionStats.kernel.size / 1024 / 1024 / 1024).toFixed(2),
                    totalSize > 0 ? `${((deletionStats.kernel.size / totalSize) * 100).toFixed(1)}%` : '0%'
                  ],
                  ['APT Packages',
                    deletionStats.apt.count.toString(),
                    (deletionStats.apt.size / 1024 / 1024 / 1024).toFixed(2),
                    totalSize > 0 ? `${((deletionStats.apt.size / totalSize) * 100).toFixed(1)}%` : '0%'
                  ],
                  ['Other',
                    deletionStats.other.count.toString(),
                    (deletionStats.other.size / 1024 / 1024 / 1024).toFixed(2),
                    totalSize > 0 ? `${((deletionStats.other.size / totalSize) * 100).toFixed(1)}%` : '0%'
                  ]
                ]);
              
              // ccache format breakdown
              if (deletionStats.ccache.count > 0) {
                summary.addHeading('üîë ccache Format Breakdown', 3)
                  .addTable([
                    [{data: 'Format', header: true}, {data: 'Count', header: true}, {data: 'Percentage', header: true}],
                    ['v3 (New Format)', deletionStats.ccache.v3.toString(), `${((deletionStats.ccache.v3 / deletionStats.ccache.count) * 100).toFixed(1)}%`],
                    ['Legacy (Old Format)', deletionStats.ccache.legacy.toString(), `${((deletionStats.ccache.legacy / deletionStats.ccache.count) * 100).toFixed(1)}%`],
                    ['Stable Keys', deletionStats.ccache.stable.toString(), `${((deletionStats.ccache.stable / deletionStats.ccache.count) * 100).toFixed(1)}%`]
                  ]);
              }
            }
            
            // Add top 20 largest caches
            if (deletedCaches.length > 0) {
              const topCaches = deletedCaches
                .sort((a, b) => parseFloat(b.size) - parseFloat(a.size))
                .slice(0, 20);
              
              summary.addHeading('üì¶ Top 20 Largest Caches ' + (dryRun ? 'to Delete' : 'Deleted'), 3)
                .addTable([
                  [{data: 'Cache Key', header: true}, {data: 'Size (MB)', header: true}, {data: 'Created Age', header: true}, {data: 'Access Age', header: true}, {data: 'Type', header: true}, {data: 'Format', header: true}],
                  ...topCaches.map(c => [
                    c.key.length > 70 ? c.key.substring(0, 67) + '...' : c.key, 
                    c.size, 
                    `${c.createdAge}d`, 
                    `${c.accessAge}d`,
                    c.category,
                    c.isV3 ? 'v3' : 'legacy'
                  ])
                ]);
            }
            
            // Add most stale caches (by access)
            if (deletedCaches.length > 0) {
              const stalestCaches = deletedCaches
                .sort((a, b) => b.accessAge - a.accessAge)
                .slice(0, 10);
              
              summary.addHeading('üï∞Ô∏è Top 10 Most Stale Caches (by Last Access) ' + (dryRun ? 'to Delete' : 'Deleted'), 3)
                .addTable([
                  [{data: 'Cache Key', header: true}, {data: 'Access Age', header: true}, {data: 'Created Age', header: true}, {data: 'Size (MB)', header: true}, {data: 'Type', header: true}],
                  ...stalestCaches.map(c => [
                    c.key.length > 70 ? c.key.substring(0, 67) + '...' : c.key,
                    `${c.accessAge}d`, 
                    `${c.createdAge}d`,
                    c.size, 
                    c.category
                  ])
                ]);
            }
            
            // Device breakdown for ccache deletions
            if (deletionStats.ccache.count > 0) {
              const deviceDeletions = new Map();
              for (const cache of deletedCaches) {
                if (cache.category === 'ccache' && cache.device) {
                  if (!deviceDeletions.has(cache.device)) {
                    deviceDeletions.set(cache.device, { 
                      count: 0, 
                      size: 0,
                      v3: 0,
                      legacy: 0
                    });
                  }
                  const data = deviceDeletions.get(cache.device);
                  data.count++;
                  data.size += cache.sizeBytes;
                  if (cache.isV3) {
                    data.v3++;
                  } else {
                    data.legacy++;
                  }
                }
              }
              
              if (deviceDeletions.size > 0) {
                const topDevices = Array.from(deviceDeletions.entries())
                  .sort((a, b) => b[1].size - a[1].size)
                  .slice(0, 10);
                
                summary.addHeading('üì± Top 10 Devices by Deleted ccache', 3)
                  .addTable([
                    [{data: 'Device', header: true}, {data: 'Caches', header: true}, {data: 'Size (GB)', header: true}, {data: 'v3/Legacy', header: true}],
                    ...topDevices.map(([device, data]) => [
                      device,
                      data.count.toString(),
                      (data.size / 1024 / 1024 / 1024).toFixed(2),
                      `${data.v3}/${data.legacy}`
                    ])
                  ]);
              }
            }
            
            // Add failures if any
            if (skippedCaches.length > 0) {
              summary.addHeading('‚ö†Ô∏è Failed Deletions', 3)
                .addTable([
                  [{data: 'Cache Key', header: true}, {data: 'Reason', header: true}],
                  ...skippedCaches.map(c => [c.key, c.reason])
                ]);
            }
            
            summary.write();

  cleanup-runs:
    runs-on: ubuntu-latest
    needs: analyze
    if: |
      always() &&
      (inputs.cleanup_type == 'runs_only' || inputs.cleanup_type == 'full_cleanup') &&
      (inputs.cleanup_type != 'analyze_only')
    
    steps:
      - name: üóëÔ∏è Clean old workflow runs
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const keepRecent = parseInt('${{ inputs.keep_recent_runs }}');
            const daysToKeep = parseInt('${{ inputs.days_to_keep }}');
            const dryRun = '${{ inputs.dry_run }}' === 'true';
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);
            
            console.log(`üìÖ Configuration:`);
            console.log(`   - Keeping runs from: ${cutoffDate.toISOString()}`);
            console.log(`   - Keeping ${keepRecent} most recent successful runs per workflow`);
            console.log(`   - Dry Run: ${dryRun}\n`);
            
            const workflows = await github.rest.actions.listRepoWorkflows({
              owner,
              repo
            });
            
            let totalDeleted = 0;
            let totalFailed = 0;
            const workflowStats = [];
            
            for (const workflow of workflows.data.workflows) {
              console.log(`\nüìã Processing: ${workflow.name}`);
              
              let page = 1;
              let successfulRuns = [];
              let deletedInWorkflow = 0;
              let failedInWorkflow = 0;
              
              const runsByStatus = {
                success: 0,
                failure: 0,
                cancelled: 0,
                skipped: 0,
                other: 0
              };
              
              while (true) {
                const runs = await github.rest.actions.listWorkflowRuns({
                  owner,
                  repo,
                  workflow_id: workflow.id,
                  per_page: 100,
                  page: page
                });
                
                if (runs.data.workflow_runs.length === 0) break;
                
                for (const run of runs.data.workflow_runs) {
                  const runDate = new Date(run.created_at);
                  const ageDays = Math.floor((new Date() - runDate) / (1000 * 60 * 60 * 24));
                  
                  // Count by status
                  runsByStatus[run.conclusion || 'other']++;
                  
                  // Track successful runs
                  if (run.conclusion === 'success') {
                    successfulRuns.push(run);
                  }
                  
                  // Determine if should delete
                  const isOld = runDate < cutoffDate;
                  const isFailed = run.conclusion === 'failure';
                  const isCancelled = run.conclusion === 'cancelled';
                  const isSkipped = run.conclusion === 'skipped';
                  const tooManySuccessful = run.conclusion === 'success' && 
                                           successfulRuns.length > keepRecent;
                  
                  const shouldDelete = 
                    (isFailed && isOld) ||
                    (isCancelled && isOld) ||
                    (isSkipped && isOld) ||
                    (tooManySuccessful && isOld);
                  
                  if (shouldDelete) {
                    if (dryRun) {
                      console.log(`üîç Would delete: #${run.run_number} (${run.conclusion}, ${ageDays}d old)`);
                    } else {
                      console.log(`üóëÔ∏è Deleting: #${run.run_number} (${run.conclusion}, ${ageDays}d old)`);
                      
                      try {
                        await github.rest.actions.deleteWorkflowRun({
                          owner,
                          repo,
                          run_id: run.id
                        });
                        deletedInWorkflow++;
                        totalDeleted++;
                      } catch (error) {
                        console.log(`   ‚ö†Ô∏è Failed: ${error.message}`);
                        failedInWorkflow++;
                        totalFailed++;
                      }
                    }
                  }
                }
                
                if (runs.data.workflow_runs.length < 100) break;
                page++;
              }
              
              if (deletedInWorkflow > 0 || Object.values(runsByStatus).some(v => v > 0)) {
                workflowStats.push({
                  name: workflow.name,
                  deleted: deletedInWorkflow,
                  failed: failedInWorkflow,
                  stats: runsByStatus
                });
              }
            }
            
            console.log(`\n‚úÖ Total runs ${dryRun ? 'to delete' : 'deleted'}: ${totalDeleted}`);
            if (totalFailed > 0) {
              console.log(`‚ö†Ô∏è Failed deletions: ${totalFailed}`);
            }
            
            // Generate summary
            let summary = core.summary
              .addHeading(`üßπ Workflow Runs ${dryRun ? 'Preview' : 'Summary'}`)
              .addTable([
                [{data: 'Metric', header: true}, {data: 'Value', header: true}],
                ['Runs ' + (dryRun ? 'to Delete' : 'Deleted'), totalDeleted.toString()],
                ['Failed Deletions', totalFailed.toString()],
                ['Kept Recent Successful', keepRecent.toString()],
                ['Days Kept', daysToKeep.toString()]
              ]);
            
            if (workflowStats.length > 0) {
              summary.addHeading('üìä Per-Workflow Breakdown', 3)
                .addTable([
                  [
                    {data: 'Workflow', header: true}, 
                    {data: 'Deleted', header: true},
                    {data: 'Success', header: true},
                    {data: 'Failure', header: true},
                    {data: 'Cancelled', header: true}
                  ],
                  ...workflowStats.map(w => [
                    w.name,
                    w.deleted.toString(),
                    w.stats.success.toString(),
                    w.stats.failure.toString(),
                    w.stats.cancelled.toString()
                  ])
                ]);
            }
            
            summary.write();

  final-report:
    runs-on: ubuntu-latest
    needs: [analyze, cleanup-caches, cleanup-runs]
    if: always()
    
    steps:
      - name: üìä Final Repository Health Report
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const dryRun = '${{ inputs.dry_run }}' === 'true';
            
            console.log('üìä Generating final health report...\n');
            
            // Get current cache usage (after cleanup)
            let page = 1;
            let totalCacheSize = 0;
            let cachesByType = {
              ccache: 0,
              apt: 0,
              kernel: 0,
              other: 0
            };
            let cacheCount = 0;
            const buildFrequency = new Map();
            const recentCutoff = new Date();
            recentCutoff.setDate(recentCutoff.getDate() - 30);
            
            const cacheKeyVersions = {
              v3: 0,
              legacy: 0
            };
            
            while (true) {
              const res = await github.rest.actions.getActionsCacheList({
                owner,
                repo,
                per_page: 100,
                page: page
              });
              
              const caches = res.data.actions_caches;
              if (!caches || caches.length === 0) break;
              
              for (const cache of caches) {
                totalCacheSize += cache.size_in_bytes;
                cacheCount++;
                
                if (cache.key.startsWith('ccache-')) {
                  cachesByType.ccache += cache.size_in_bytes;
                  
                  // Track cache key versions
                  const isV3Format = cache.key.startsWith('ccache-ksun-v3-');
                  if (isV3Format) {
                    cacheKeyVersions.v3++;
                  } else {
                    cacheKeyVersions.legacy++;
                  }
                  
                  // Track build frequency - ROBUST PARSING
                  if (new Date(cache.last_accessed_at) > recentCutoff) {
                    let device = null;
                    
                    if (isV3Format) {
                      const v3Match = cache.key.match(/^ccache-ksun-v3-([^-]+-[\d.]+)-([^-]+)-(clang-[^-]+)-([^-]+)(-stable)?$/);
                      if (v3Match) {
                        device = v3Match[4];
                      }
                    } else {
                      const legacy1 = cache.key.match(/^ccache-[^-]+-[\d.]+-[^-]+-clang-[^-]+-([^-]+)$/);
                      const legacy2 = cache.key.match(/^ccache-[^-]+-[\d.]+-[^-]+-([^-]+)$/);
                      const legacy3 = cache.key.match(/ccache-[^-]+-[^-]+-[^-]+-[^-]+-([^-]+)/);
                      
                                            device = legacy1?.[1] || legacy2?.[1] || legacy3?.[1] || null;
                    }
                    
                    if (device) {
                      buildFrequency.set(device, (buildFrequency.get(device) || 0) + 1);
                    }
                  }
                } else if (cache.key.includes('apt')) {
                  cachesByType.apt += cache.size_in_bytes;
                } else if (cache.key.includes('kernel') || cache.key.includes('android') || cache.key.includes('gki')) {
                  cachesByType.kernel += cache.size_in_bytes;
                } else {
                  cachesByType.other += cache.size_in_bytes;
                }
              }
              
              if (caches.length < 100) break;
              page++;
            }
            
            const totalGB = (totalCacheSize / 1024 / 1024 / 1024).toFixed(2);
            const ccacheGB = (cachesByType.ccache / 1024 / 1024 / 1024).toFixed(2);
            const aptGB = (cachesByType.apt / 1024 / 1024 / 1024).toFixed(2);
            const kernelGB = (cachesByType.kernel / 1024 / 1024 / 1024).toFixed(2);
            const otherGB = (cachesByType.other / 1024 / 1024 / 1024).toFixed(2);
            
            const limit = 10; // 10 GB
            const usagePercent = totalCacheSize > 0 ? ((totalCacheSize / (limit * 1024 * 1024 * 1024)) * 100).toFixed(1) : '0.0';
            
            // Calculate change if we have before data
            const beforeSize = parseFloat('${{ needs.analyze.outputs.total_cache_size }}');
            const beforeCount = parseInt('${{ needs.analyze.outputs.cache_count }}');
            const beforePercent = parseFloat('${{ needs.analyze.outputs.usage_percent }}');
            
            let changeInfo = '';
            if (beforeSize > 0 && !dryRun) {
              const sizeChange = beforeSize - totalCacheSize;
              const countChange = beforeCount - cacheCount;
              const percentChange = beforePercent - parseFloat(usagePercent);
              
              const changeGB = (sizeChange / 1024 / 1024 / 1024).toFixed(2);
              
              changeInfo = `\n### üìà Cleanup Impact\n\n` +
                `- **Space Freed:** ${changeGB} GB\n` +
                `- **Caches Removed:** ${countChange}\n` +
                `- **Usage Reduced:** ${percentChange.toFixed(1)}%\n`;
            }
            
            // Determine health status
            let healthEmoji = 'üü¢';
            let healthStatus = 'Healthy';
            if (parseFloat(usagePercent) > 90) {
              healthEmoji = 'üî¥';
              healthStatus = 'Critical - Immediate Cleanup Needed!';
            } else if (parseFloat(usagePercent) > 75) {
              healthEmoji = 'üü°';
              healthStatus = 'Warning - Consider Cleanup Soon';
            }
            
            let summary = core.summary
              .addHeading(`${healthEmoji} Final Repository Health Report`)
              .addRaw(dryRun ? '\n**‚ö†Ô∏è This was a DRY RUN - No changes were made**\n\n' : '\n')
              .addTable([
                [{data: 'Cache Type', header: true}, {data: 'Size (GB)', header: true}, {data: 'Percentage', header: true}],
                ['ccache (Kernel Builds)', ccacheGB, totalCacheSize > 0 ? `${((cachesByType.ccache / totalCacheSize) * 100).toFixed(1)}%` : '0%'],
                ['Kernel-related', kernelGB, totalCacheSize > 0 ? `${((cachesByType.kernel / totalCacheSize) * 100).toFixed(1)}%` : '0%'],
                ['APT Packages', aptGB, totalCacheSize > 0 ? `${((cachesByType.apt / totalCacheSize) * 100).toFixed(1)}%` : '0%'],
                ['Other', otherGB, totalCacheSize > 0 ? `${((cachesByType.other / totalCacheSize) * 100).toFixed(1)}%` : '0%'],
                ['**Total**', `**${totalGB}**`, '**100%**']
              ])
              .addRaw(`\n### üìä Current Usage Statistics\n\n`)
              .addRaw(`- **Total Caches:** ${cacheCount}\n`)
              .addRaw(`- **Limit:** ${limit} GB\n`)
              .addRaw(`- **Current Usage:** ${totalGB} GB (${usagePercent}%)\n`)
              .addRaw(`- **Available:** ${(limit - parseFloat(totalGB)).toFixed(2)} GB\n`)
              .addRaw(`- **Status:** ${healthStatus}\n`)
              .addRaw(changeInfo);
            
            // Cache key version distribution
            if (cachesByType.ccache > 0) {
              const totalCcache = cacheKeyVersions.v3 + cacheKeyVersions.legacy;
              summary.addRaw(`\n### üîë Cache Key Versions\n\n`)
                .addTable([
                  [{data: 'Version', header: true}, {data: 'Count', header: true}, {data: 'Percentage', header: true}],
                  ['v3 (New Format)', cacheKeyVersions.v3.toString(), totalCcache > 0 ? `${((cacheKeyVersions.v3 / totalCcache) * 100).toFixed(1)}%` : '0%'],
                  ['Legacy (Old Format)', cacheKeyVersions.legacy.toString(), totalCcache > 0 ? `${((cacheKeyVersions.legacy / totalCcache) * 100).toFixed(1)}%` : '0%']
                ]);
              
              if (cacheKeyVersions.legacy > 0) {
                summary.addRaw(`\n‚ö†Ô∏è **${cacheKeyVersions.legacy} legacy caches remaining**\n`)
                  .addRaw(`- Consider cleaning with \`cache_pattern: old_only\`\n`);
              }
            }
            
            // Build activity analysis
            if (buildFrequency.size > 0) {
              const activeDevices = Array.from(buildFrequency.entries())
                .filter(([_, count]) => count >= 3)
                .sort((a, b) => b[1] - a[1]);
              
              summary.addRaw(`\n### üì± Build Activity Analysis (Last 30 Days)\n\n`)
                .addRaw(`- **Active Devices:** ${activeDevices.length}\n`)
                .addRaw(`- **Total Build Events:** ${Array.from(buildFrequency.values()).reduce((a, b) => a + b, 0)}\n`);
              
              if (activeDevices.length > 0) {
                const topActive = activeDevices.slice(0, 10);
                summary.addRaw(`\n**Top 10 Most Active Devices:**\n`)
                  .addTable([
                    [{data: 'Device', header: true}, {data: 'Build Events', header: true}],
                    ...topActive.map(([device, count]) => [device, count.toString()])
                  ]);
              }
            }
            
            summary.addRaw(`\n### üí° Next Steps\n\n`);
            
            if (dryRun) {
              summary.addRaw(`- ‚ÑπÔ∏è This was a dry run - run again with \`dry_run: false\` to apply changes\n`);
            } else if (parseFloat(usagePercent) > 75) {
              summary.addRaw(`- ‚ö†Ô∏è **Action Required:** Usage still high, consider additional cleanup\n`)
                .addRaw(`- Target specific devices or cache types\n`)
                .addRaw(`- Review ccache size limits\n`);
            } else {
              summary.addRaw(`- ‚úÖ Cache usage is now healthy\n`)
                .addRaw(`- Schedule regular cleanup (weekly recommended)\n`)
                .addRaw(`- Monitor usage trends\n`);
            }
            
            summary.addRaw(`\n### üîÑ Cleanup Schedule Recommendations\n\n`)
              .addRaw(`- **Daily:** If building > 10 devices regularly\n`)
              .addRaw(`- **Weekly:** For moderate usage (5-10 devices)\n`)
              .addRaw(`- **Monthly:** For light usage (< 5 devices)\n`)
              .addRaw(`- **On-demand:** When usage exceeds 75%\n`);
            
            summary.write();
            
            console.log(`\n‚úÖ Final report generated`);
            console.log(`   - Current usage: ${totalGB} GB (${usagePercent}%)`);
            console.log(`   - Status: ${healthStatus}`);
            console.log(`   - v3 caches: ${cacheKeyVersions.v3}, Legacy: ${cacheKeyVersions.legacy}`);

      - name: üí° Quick Action Commands
        if: always()
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          
          ---
          
          ## üöÄ Quick Action Commands
          
          ### High Usage Cleanup (>75%)
          ```bash
          # Clean all old caches (>7 days by creation)
          gh workflow run cleanup.yml \
            -f cleanup_type=cache_only \
            -f cache_pattern=old_only \
            -f cache_age_days=7
          
          # Clean stale ccache (>14 days since last access)
          gh workflow run cleanup.yml \
            -f cleanup_type=cache_only \
            -f cache_pattern=ccache_stale
          
          # Clean legacy format caches
          gh workflow run cleanup.yml \
            -f cleanup_type=cache_only \
            -f cache_pattern=old_only \
            -f cache_age_days=14
          
          # Clean specific device
          gh workflow run cleanup.yml \
            -f cleanup_type=cache_only \
            -f device_filter=OP13 \
            -f cache_pattern=ccache_only
          ```
          
          ### Regular Maintenance
          ```bash
          # Weekly cleanup (recommended)
          gh workflow run cleanup.yml \
            -f cleanup_type=full_cleanup \
            -f cache_age_days=14
          
          # Analyze only (no changes)
          gh workflow run cleanup.yml \
            -f cleanup_type=analyze_only
          
          # Dry run preview
          gh workflow run cleanup.yml \
            -f cleanup_type=cache_only \
            -f dry_run=true
          ```
          
          ### Emergency Cleanup
          ```bash
          # Force cleanup everything old
          gh workflow run cleanup.yml \
            -f cleanup_type=full_cleanup \
            -f force_cleanup=true \
            -f cache_age_days=3
          
          # Clean all ccache immediately
          gh workflow run cleanup.yml \
            -f cleanup_type=cache_only \
            -f cache_pattern=ccache_only \
            -f force_cleanup=true
          
          # Clean all legacy caches
          gh workflow run cleanup.yml \
            -f cleanup_type=cache_only \
            -f cache_pattern=old_only \
            -f cache_age_days=0 \
            -f force_cleanup=true
          ```
          
          ### Device-Specific Cleanup
          ```bash
          # Clean by kernel version
          gh workflow run cleanup.yml \
            -f cleanup_type=cache_only \
            -f device_filter=android15-6.6 \
            -f cache_pattern=ccache_only
          
          # Clean specific phone model
          gh workflow run cleanup.yml \
            -f cleanup_type=cache_only \
            -f device_filter=OP13 \
            -f cache_pattern=all_caches
          
          # Clean OnePlus 12 series
          gh workflow run cleanup.yml \
            -f cleanup_type=cache_only \
            -f device_filter=OP12 \
            -f cache_pattern=ccache_only
          ```
          
          ### Workflow Runs Cleanup
          ```bash
          # Clean old workflow runs
          gh workflow run cleanup.yml \
            -f cleanup_type=runs_only \
            -f days_to_keep=7 \
            -f keep_recent_runs=3
          
          # Aggressive run cleanup
          gh workflow run cleanup.yml \
            -f cleanup_type=runs_only \
            -f days_to_keep=3 \
            -f keep_recent_runs=1
          ```
          
          ### Migration from Legacy to v3
          ```bash
          # Step 1: Analyze current state
          gh workflow run cleanup.yml \
            -f cleanup_type=analyze_only
          
          # Step 2: Preview legacy cache cleanup
          gh workflow run cleanup.yml \
            -f cleanup_type=cache_only \
            -f cache_pattern=old_only \
            -f cache_age_days=7 \
            -f dry_run=true
          
          # Step 3: Clean legacy caches
          gh workflow run cleanup.yml \
            -f cleanup_type=cache_only \
            -f cache_pattern=old_only \
            -f cache_age_days=7
          
          # Step 4: Verify new v3 caches are working
          # (Run your build workflow)
          
          # Step 5: Clean remaining legacy caches
          gh workflow run cleanup.yml \
            -f cleanup_type=cache_only \
            -f cache_pattern=old_only \
            -f cache_age_days=0 \
            -f force_cleanup=true
          ```
          
          ### Troubleshooting
          ```bash
          # Check what would be deleted (safe preview)
          gh workflow run cleanup.yml \
            -f cleanup_type=cache_only \
            -f cache_pattern=all_caches \
            -f dry_run=true
          
          # Clean only APT caches if builds are slow
          gh workflow run cleanup.yml \
            -f cleanup_type=cache_only \
            -f cache_pattern=apt_only
          
          # Clean everything except recent (nuclear option)
          gh workflow run cleanup.yml \
            -f cleanup_type=full_cleanup \
            -f cache_age_days=1 \
            -f days_to_keep=1 \
            -f force_cleanup=true
          ```
          
          ---
          
          ## üìã Cache Key Format Reference
          
          ### v3 Format (Current - Recommended)
          ```
          ccache-ksun-v3-<kernel>-<os>-<clang>-<device>[-stable]
          
          Example:
          ccache-ksun-v3-android15-6.6-OOS15-clang-r123456-OP13-stable
          ```
          
          **Components:**
          - `ccache-ksun-v3`: Version identifier
          - `android15-6.6`: Kernel version (can contain hyphens)
          - `OOS15`: OS version
          - `clang-r123456`: Compiler version
          - `OP13`: Device model
          - `-stable`: Stable key marker (optional, used for canonical save/restore)
          
          **Notes:**
          - The `-stable` suffix is used for the primary save/restore key in builds
          - Fallback restore keys may omit the `-stable` suffix
          - This format allows better cache sharing between similar configurations
          
          ### Legacy Format (Deprecated)
          ```
          ccache-<kernel>-<os>-<clang>-<device>
          
          Example:
          ccache-android15-6.6-OOS15-clang-r123456-OP13
          ```
          
          **Migration:** Legacy caches can be safely removed once v3 format is confirmed working.
          
          ---
          
          ## üéØ Best Practices
          
          1. **Always preview first**: Use `dry_run=true` to see what will be deleted
          2. **Regular maintenance**: Run weekly cleanup with `cache_pattern=ccache_stale`
          3. **Monitor usage**: Run `analyze_only` regularly to track trends
          4. **Device-specific**: Target specific devices when building multiple models
          5. **Legacy migration**: Clean old format caches after confirming v3 works
          6. **Emergency only**: Use `force_cleanup=true` only when necessary
          7. **Keep recent**: Don't set `cache_age_days` too low (minimum 3 days recommended)
          8. **Protect stable**: v3 stable keys are protected unless very stale (30+ days)
          9. **Access-based**: Use `ccache_stale` for access-based cleanup (better than age-based)
          10. **Test first**: Always test with one device before cleaning all
          
          ---
          
          ## üîç Understanding Cache Patterns
          
          | Pattern | Target | Basis | Use Case |
          |---------|--------|-------|----------|
          | `all_caches` | Everything | N/A | Full cleanup |
          | `ccache_only` | Kernel build caches | N/A | Free space for builds |
          | `ccache_stale` | Caches >14 days | **Last access** | Remove unused device caches (recommended) |
          | `apt_only` | APT packages | N/A | Rarely needed |
          | `kernel_only` | Kernel-related (excludes apt) | N/A | Target kernel artifacts |
          | `old_only` | Caches older than N days | **Creation date** | Age-based cleanup |
          
          **Key Difference:**
          - `ccache_stale`: Uses **last_accessed_at** (better for finding truly unused caches)
          - `old_only`: Uses **created_at** (removes old caches regardless of usage)
          
          ---
          
          ## ‚ö†Ô∏è Important Notes
          
          ### GitHub Cache Limits
          - **Total limit**: 10 GB per repository
          - **Eviction policy**: GitHub may evict caches that haven't been accessed recently (typically around 7 days)
          - **Not guaranteed**: Eviction is based on internal policies and is not strictly guaranteed by age
          - **LRU-based**: Least Recently Used caches are evicted first when limit is reached
          
          ### Cache Protection
          - **v3 stable keys**: Protected from `ccache_stale` cleanup unless >30 days since last access
          - **Force override**: Use `force_cleanup=true` to bypass protection
          - **Active builds**: Cleanup doesn't affect currently running builds
          
          ### Performance Impact
          - **First build**: Will be slower after cache cleanup (full compilation)
          - **Subsequent builds**: Normal speed once cache is rebuilt
          - **Parallel builds**: Multiple devices can share v3 format caches
          
          ### Timing
          - **Creation date** (`created_at`): When cache was first saved
          - **Last access** (`last_accessed_at`): When cache was last restored in a workflow
          - **Staleness**: Measured by last access, not creation (more accurate)
          
          ---
          
          ## üìä Cleanup Strategy Guide
          
          ### For High Usage (>75%)
          1. Run `analyze_only` to identify largest consumers
          2. Use `ccache_stale` to remove unused caches (by access)
          3. Target inactive devices specifically
          4. Clean legacy format caches
          5. Consider reducing `CCACHE_MAXSIZE` in build workflows
          
          ### For Regular Maintenance
          1. Weekly: `ccache_stale` pattern (removes caches not accessed in 14+ days)
          2. Monthly: `old_only` with 30+ days (removes old caches by creation)
          3. Quarterly: Full analysis and review
          
          ### For Migration
          1. Confirm v3 format is working (check recent builds)
          2. Preview legacy cleanup with `dry_run=true`
          3. Clean legacy caches in stages (by device or age)
          4. Monitor build times after cleanup
          5. Keep at least one successful build per device
          
          ---
          
          **üí° Pro Tip:** Use `ccache_stale` instead of `old_only` for smarter cleanup based on actual usage!
          
          **üìö Documentation:** 
          - [GitHub Actions Cache Documentation](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows)
          - [Cache Eviction Policy](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows#usage-limits-and-eviction-policy)
          
          EOF
